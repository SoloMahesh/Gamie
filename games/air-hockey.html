<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Hockey</title>
    <style>
        body { margin: 0; background: #222; overflow: hidden; font-family: 'Segoe UI', sans-serif; touch-action: none; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { border: 5px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); background: #fff; }
        #score { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg); font-size: 4rem; color: rgba(0,0,0,0.1); font-weight: bold; pointer-events: none; white-space: nowrap; }
        .controls-hint { position: absolute; bottom: 20px; color: rgba(255,255,255,0.5); pointer-events: none; }
    </style>
</head>
<body>
    <div id="score">0 - 0</div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls-hint">Touch Top/Bottom to Control Paddles</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        const PUCK_RADIUS = 15;
        const PADDLE_RADIUS = 30;
        const GOAL_WIDTH = 120;

        let score1 = 0; // Top player
        let score2 = 0; // Bottom player

        // Game objects
        let puck = { x: 0, y: 0, vx: 0, vy: 0 };
        let paddle1 = { x: 0, y: 0, vx: 0, vy: 0 }; // Top
        let paddle2 = { x: 0, y: 0, vx: 0, vy: 0 }; // Bottom

        // Input state
        let touches = {};

        function resize() {
            width = Math.min(window.innerWidth, 500);
            height = Math.min(window.innerHeight, 800);
            canvas.width = width;
            canvas.height = height;
            resetGame();
        }
        window.addEventListener('resize', resize);

        function resetGame() {
            puck.x = width / 2;
            puck.y = height / 2;
            puck.vx = 0;
            puck.vy = 0;

            paddle1.x = width / 2;
            paddle1.y = 100;

            paddle2.x = width / 2;
            paddle2.y = height - 100;
        }

        function update() {
            // Apply friction
            puck.vx *= 0.99;
            puck.vy *= 0.99;

            // Move puck
            puck.x += puck.vx;
            puck.y += puck.vy;

            // Wall collisions (Left/Right)
            if (puck.x < PUCK_RADIUS) {
                puck.x = PUCK_RADIUS;
                puck.vx = -puck.vx * 0.8;
            } else if (puck.x > width - PUCK_RADIUS) {
                puck.x = width - PUCK_RADIUS;
                puck.vx = -puck.vx * 0.8;
            }

            // Wall collisions (Top/Bottom) - Check Goal
            if (puck.y < PUCK_RADIUS) {
                if (puck.x > width/2 - GOAL_WIDTH/2 && puck.x < width/2 + GOAL_WIDTH/2) {
                    score2++; // Bottom wins
                    resetPuck(2);
                } else {
                    puck.y = PUCK_RADIUS;
                    puck.vy = -puck.vy * 0.8;
                }
            } else if (puck.y > height - PUCK_RADIUS) {
                if (puck.x > width/2 - GOAL_WIDTH/2 && puck.x < width/2 + GOAL_WIDTH/2) {
                    score1++; // Top wins
                    resetPuck(1);
                } else {
                    puck.y = height - PUCK_RADIUS;
                    puck.vy = -puck.vy * 0.8;
                }
            }

            // Paddle collisions
            checkPaddleCollision(paddle1);
            checkPaddleCollision(paddle2);

            // Update UI
            // Rotate score for players facing each other? simpler to just show number
            document.getElementById('score').innerText = `${score1} - ${score2}`;
        }

        function resetPuck(winner) {
            puck.x = width / 2;
            puck.y = height / 2;
            puck.vx = 0;
            puck.vy = 0;
            // Maybe serve to loser?
            puck.y = winner === 1 ? height/2 + 50 : height/2 - 50;
        }

        function checkPaddleCollision(p) {
            let dx = puck.x - p.x;
            let dy = puck.y - p.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < PUCK_RADIUS + PADDLE_RADIUS) {
                // Collision!
                // Resolve overlap
                let overlap = (PUCK_RADIUS + PADDLE_RADIUS) - dist;
                let angle = Math.atan2(dy, dx);
                puck.x += Math.cos(angle) * overlap;
                puck.y += Math.sin(angle) * overlap;

                // Bounce
                // Simple elastic collision approx adding paddle velocity
                let speed = Math.sqrt(puck.vx*puck.vx + puck.vy*puck.vy);
                // Add paddle hit force
                // We don't track paddle velocity perfectly here (instant move), so infer

                puck.vx = Math.cos(angle) * (speed + 5);
                puck.vy = Math.sin(angle) * (speed + 5);

                // Cap speed
                let maxSpeed = 15;
                if (puck.vx > maxSpeed) puck.vx = maxSpeed;
                if (puck.vy > maxSpeed) puck.vy = maxSpeed;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Field lines
            ctx.strokeStyle = "#e74c3c"; // Center line
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height/2);
            ctx.lineTo(width, height/2);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(width/2, height/2, 50, 0, Math.PI*2);
            ctx.stroke();

            // Goals
            ctx.fillStyle = "#ddd";
            ctx.fillRect(width/2 - GOAL_WIDTH/2, 0, GOAL_WIDTH, 10);
            ctx.fillRect(width/2 - GOAL_WIDTH/2, height - 10, GOAL_WIDTH, 10);

            // Paddles
            ctx.fillStyle = "#3498db"; // Top
            ctx.beginPath();
            ctx.arc(paddle1.x, paddle1.y, PADDLE_RADIUS, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = "#2980b9";
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.fillStyle = "#e74c3c"; // Bottom
            ctx.beginPath();
            ctx.arc(paddle2.x, paddle2.y, PADDLE_RADIUS, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = "#c0392b";
            ctx.stroke();

            // Puck
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(puck.x, puck.y, PUCK_RADIUS, 0, Math.PI*2);
            ctx.fill();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Input Handling
        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); }, {passive: false});

        // Mouse for desktop debugging (controls bottom paddle)
        canvas.addEventListener('mousemove', (e) => {
            let rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            if (y > height/2) {
                paddle2.x = x;
                paddle2.y = y;
            }
        });

        function handleTouch(e) {
            e.preventDefault();
            let rect = canvas.getBoundingClientRect();

            for (let i = 0; i < e.touches.length; i++) {
                let t = e.touches[i];
                let x = t.clientX - rect.left;
                let y = t.clientY - rect.top;

                if (y < height/2) {
                    // Top half -> Paddle 1
                    paddle1.x = x;
                    paddle1.y = y;
                } else {
                    // Bottom half -> Paddle 2
                    paddle2.x = x;
                    paddle2.y = y;
                }
            }
        }

        resize();
        loop();
    </script>
</body>
</html>
