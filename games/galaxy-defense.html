<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Defense</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; color: white; }
        canvas { display: block; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #topBar { background: rgba(0,0,0,0.8); padding: 10px; display: flex; justify-content: space-between; font-size: 1.2rem; pointer-events: auto; }
        #buildMenu { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; gap: 10px; padding: 10px; pointer-events: auto; }
        .tower-btn { width: 60px; height: 60px; border: 2px solid #555; background: #222; border-radius: 5px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.8rem; }
        .tower-btn.selected { border-color: #0ff; background: #333; }
        .tower-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .icon { font-size: 1.5rem; margin-bottom: 2px; }
        #waveInfo { color: #f39c12; }
        #moneyInfo { color: #2ecc71; }
        #livesInfo { color: #e74c3c; }
        #startBtn { padding: 5px 15px; background: #3498db; border: none; color: white; border-radius: 3px; cursor: pointer; }
        #gameOver { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="topBar">
            <div id="moneyInfo">Credits: <span id="moneyVal">100</span></div>
            <div id="livesInfo">Lives: <span id="livesVal">20</span></div>
            <div id="waveInfo">Wave: <span id="waveVal">1</span></div>
            <button id="startBtn" onclick="nextWave()">Start Wave</button>
        </div>

        <div id="buildMenu">
            <div class="tower-btn selected" id="btnTower1" onclick="selectTower(0)">
                <div class="icon" style="color:#3498db">●</div>
                <div>$50</div>
            </div>
            <div class="tower-btn" id="btnTower2" onclick="selectTower(1)">
                <div class="icon" style="color:#e74c3c">▲</div>
                <div>$120</div>
            </div>
            <div class="tower-btn" id="btnTower3" onclick="selectTower(2)">
                <div class="icon" style="color:#f1c40f">★</div>
                <div>$300</div>
            </div>
        </div>
    </div>

    <div id="gameOver">
        <h1>GAME OVER</h1>
        <button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.5rem;">Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // Game Config
        const tileSize = 40;
        let cols, rows;
        let map = [];
        let path = [];

        // State
        let money = 150;
        let lives = 20;
        let wave = 0;
        let waveActive = false;
        let enemies = [];
        let towers = [];
        let projectiles = [];
        let particles = [];

        let selectedTowerType = 0;
        const towerTypes = [
            { name: "Laser", cost: 50, range: 120, damage: 10, rate: 30, color: "#3498db" },
            { name: "Missile", cost: 120, range: 180, damage: 40, rate: 80, color: "#e74c3c" }, // Slow, splash
            { name: "Plasma", cost: 300, range: 100, damage: 5, rate: 5, color: "#f1c40f" }   // Fast
        ];

        // Init Map
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            cols = Math.floor(width / tileSize);
            rows = Math.floor(height / tileSize);

            generateMap();
        }
        window.addEventListener('resize', resize);

        function generateMap() {
            // Simple winding path
            path = [];
            let curr = {x: 0, y: Math.floor(rows/2)};
            path.push({...curr});

            while(curr.x < cols - 1) {
                // Randomly move right or change y
                let move = Math.random();
                if (move < 0.7 || curr.x === 0) {
                    curr.x++;
                } else {
                    // Up or down?
                    if (curr.y > 2 && curr.y < rows - 3) {
                        curr.y += Math.random() > 0.5 ? 1 : -1;
                    } else if (curr.y <= 2) {
                        curr.y++;
                    } else {
                        curr.y--;
                    }
                }
                path.push({...curr});
            }
        }

        function selectTower(idx) {
            selectedTowerType = idx;
            document.querySelectorAll('.tower-btn').forEach((b, i) => {
                b.classList.toggle('selected', i === idx);
            });
        }

        function nextWave() {
            if (waveActive) return;
            wave++;
            document.getElementById('waveVal').innerText = wave;
            waveActive = true;
            document.getElementById('startBtn').disabled = true;

            let count = 5 + wave * 2;
            let hp = 20 + wave * 10;
            let speed = 1 + wave * 0.1;

            let spawned = 0;
            let spawnInterval = setInterval(() => {
                enemies.push({
                    pathIdx: 0,
                    x: path[0].x * tileSize + tileSize/2,
                    y: path[0].y * tileSize + tileSize/2,
                    hp: hp,
                    maxHp: hp,
                    speed: speed,
                    frozen: 0
                });
                spawned++;
                if (spawned >= count) clearInterval(spawnInterval);
            }, 1000);
        }

        // Input
        canvas.addEventListener('click', (e) => {
            if (waveActive && enemies.length > 0) return; // Optional: build during wave? Yes allowed.

            const rect = canvas.getBoundingClientRect();
            const cx = Math.floor((e.clientX - rect.left) / tileSize);
            const cy = Math.floor((e.clientY - rect.top) / tileSize);

            // Check bounds
            if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) return;

            // Check path collision
            if (path.some(p => p.x === cx && p.y === cy)) return;

            // Check existing tower
            if (towers.some(t => t.cx === cx && t.cy === cy)) return; // Maybe sell/upgrade?

            // Buy
            const type = towerTypes[selectedTowerType];
            if (money >= type.cost) {
                money -= type.cost;
                updateStats();
                towers.push({
                    cx: cx, cy: cy,
                    x: cx * tileSize + tileSize/2,
                    y: cy * tileSize + tileSize/2,
                    type: selectedTowerType,
                    cooldown: 0
                });
            }
        });

        function updateStats() {
            document.getElementById('moneyVal').innerText = money;
            document.getElementById('livesVal').innerText = lives;

            // Update buttons
            towerTypes.forEach((t, i) => {
                const btn = document.getElementById('btnTower' + (i+1));
                if (money < t.cost) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            });
        }

        function update() {
            // Update Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                // Move
                let target = path[e.pathIdx + 1];
                if (!target) {
                    // Reached end
                    lives--;
                    updateStats();
                    enemies.splice(i, 1);
                    if (lives <= 0) gameOver();
                    continue;
                }

                let tx = target.x * tileSize + tileSize/2;
                let ty = target.y * tileSize + tileSize/2;

                let dx = tx - e.x;
                let dy = ty - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < e.speed) {
                    e.pathIdx++;
                    e.x = tx;
                    e.y = ty;
                } else {
                    e.x += (dx / dist) * e.speed;
                    e.y += (dy / dist) * e.speed;
                }
            }

            // Wave End Check
            if (waveActive && enemies.length === 0) {
                 // Check if still spawning? No, simplified logic assuming spawn done if array empty
                 // We need to know if spawning finished.
                 // Assuming spawning is fast relative to wave clear.
                 // Let's add 'spawning' flag if needed, but for now user clicks start.
                 waveActive = false;
                 document.getElementById('startBtn').disabled = false;
            }

            // Towers Fire
            towers.forEach(t => {
                if (t.cooldown > 0) t.cooldown--;
                else {
                    // Find target
                    let target = null;
                    let minD = 9999;
                    const stats = towerTypes[t.type];

                    enemies.forEach(e => {
                        let d = Math.sqrt((e.x - t.x)**2 + (e.y - t.y)**2);
                        if (d <= stats.range && d < minD) {
                            minD = d;
                            target = e;
                        }
                    });

                    if (target) {
                        // Fire
                        projectiles.push({
                            x: t.x, y: t.y,
                            tx: target.x, ty: target.y, // Homing or predicted?
                            target: target,
                            speed: 10,
                            damage: stats.damage,
                            color: stats.color,
                            type: t.type
                        });
                        t.cooldown = stats.rate;
                    }
                }
            });

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];

                if (!enemies.includes(p.target)) {
                    projectiles.splice(i, 1);
                    continue;
                }

                let dx = p.target.x - p.x;
                let dy = p.target.y - p.y;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < p.speed) {
                    // Hit
                    p.target.hp -= p.damage;
                    createParticles(p.target.x, p.target.y, p.color);

                    if (p.target.hp <= 0) {
                        // Kill
                        const idx = enemies.indexOf(p.target);
                        if (idx !== -1) {
                            enemies.splice(idx, 1);
                            money += 10 + wave;
                            updateStats();
                        }
                    }
                    projectiles.splice(i, 1);
                } else {
                    p.x += (dx/dist) * p.speed;
                    p.y += (dy/dist) * p.speed;
                }
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                particles[i].life--;
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                if(particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function createParticles(x, y, color) {
            for(let i=0; i<5; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5)*2,
                    vy: (Math.random()-0.5)*2,
                    life: 20,
                    color: color
                });
            }
        }

        function gameOver() {
            document.getElementById('gameOver').style.display = 'flex';
        }

        function draw() {
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, width, height);

            // Draw Path
            ctx.strokeStyle = "#222";
            ctx.lineWidth = tileSize * 0.8;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            if (path.length > 0) {
                ctx.moveTo(path[0].x * tileSize + tileSize/2, path[0].y * tileSize + tileSize/2);
                for(let i=1; i<path.length; i++) {
                    ctx.lineTo(path[i].x * tileSize + tileSize/2, path[i].y * tileSize + tileSize/2);
                }
            }
            ctx.stroke();

            // Draw Grid (Subtle)
            ctx.strokeStyle = "#1a1a1a";
            ctx.lineWidth = 1;
            for(let r=0; r<=rows; r++) { ctx.beginPath(); ctx.moveTo(0, r*tileSize); ctx.lineTo(width, r*tileSize); ctx.stroke(); }
            for(let c=0; c<=cols; c++) { ctx.beginPath(); ctx.moveTo(c*tileSize, 0); ctx.lineTo(c*tileSize, height); ctx.stroke(); }

            // Towers
            towers.forEach(t => {
                ctx.fillStyle = towerTypes[t.type].color;
                ctx.fillRect(t.x - 10, t.y - 10, 20, 20);
                // Range circle
                // ctx.strokeStyle = "rgba(255,255,255,0.1)";
                // ctx.beginPath(); ctx.arc(t.x, t.y, towerTypes[t.type].range, 0, Math.PI*2); ctx.stroke();
            });

            // Enemies
            enemies.forEach(e => {
                ctx.fillStyle = "#8e44ad";
                ctx.beginPath();
                ctx.arc(e.x, e.y, 10, 0, Math.PI*2);
                ctx.fill();

                // HP Bar
                const hpPct = e.hp / e.maxHp;
                ctx.fillStyle = "red";
                ctx.fillRect(e.x - 10, e.y - 15, 20, 3);
                ctx.fillStyle = "green";
                ctx.fillRect(e.x - 10, e.y - 15, 20 * hpPct, 3);
            });

            // Projectiles
            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
            });

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 20;
                ctx.fillRect(p.x, p.y, 2, 2);
            });
            ctx.globalAlpha = 1;
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        resize();
        updateStats();
        loop();

    </script>
</body>
</html>
