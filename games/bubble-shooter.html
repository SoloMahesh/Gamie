<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter</title>
    <style>
        body {
            margin: 0;
            background: #222;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            touch-action: none;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            background: #333;
            border: 2px solid #555;
        }

        #ui {
            position: absolute;
            top: 10px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
        }

        #gameOver {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        button {
            padding: 15px 30px;
            font-size: 1.5rem;
            background: #9c27b0;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <div id="ui">Score: <span id="score">0</span> | <span style="color: #FFE138;">Best: <span
                id="highScore">0</span></span></div>
    <canvas id="gameCanvas"></canvas>

    <div id="gameOver">
        <h1 id="gameOverTitle">GAME OVER</h1>
        <p id="highScoreMsg" style="color: #FFE138; font-size: 1.5rem; display: none;">üèÜ NEW HIGH SCORE! üèÜ</p>
        <p>Score: <span id="finalScore">0</span></p>
        <p style="color: #888; font-size: 1rem;">Best: <span id="modalHighScore">0</span></p>
        <button onclick="initGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        const BUBBLE_RADIUS = 20;
        const GRID_ROWS = 10;
        let GRID_COLS;
        const COLORS = ['#f44336', '#2196f3', '#4caf50', '#ffeb3b', '#9c27b0'];

        let grid = [];
        let particles = [];
        let currentBubble = null;
        let nextBubbleColor = null;
        let score = 0;
        let highScore = localStorage.getItem('bubbleShooterHighScore') || 0;
        let gameActive = true;
        let angle = -Math.PI / 2;

        // Touch aim
        let aimX = 0;
        let aimY = 0;

        function resize() {
            width = Math.min(window.innerWidth, 600);
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            GRID_COLS = Math.floor(width / (BUBBLE_RADIUS * 2));
        }
        window.addEventListener('resize', () => { resize(); if (gameActive) initGame(); });
        resize();

        class Bubble {
            constructor(x, y, color, r, c) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.r = r; // grid row
                this.c = c; // grid col
                this.active = true;
            }

            draw() {
                if (!this.active) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, BUBBLE_RADIUS - 1, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                // Shine
                ctx.beginPath();
                ctx.arc(this.x - 5, this.y - 5, 5, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.fill();
            }
        }

        class Projectile {
            constructor(x, y, angle, color) {
                this.x = x;
                this.y = y;
                this.dx = Math.cos(angle) * 10;
                this.dy = Math.sin(angle) * 10;
                this.color = color;
                this.radius = BUBBLE_RADIUS;
                this.stopped = false;
            }

            update() {
                if (this.stopped) return;
                this.x += this.dx;
                this.y += this.dy;

                // Wall collision
                if (this.x - this.radius < 0 || this.x + this.radius > width) {
                    this.dx = -this.dx;
                    this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
                }

                // Top collision
                if (this.y - this.radius < 0) {
                    snapToGrid(this);
                }

                // Grid collision
                for (let r = 0; r < grid.length; r++) {
                    for (let c = 0; c < grid[r].length; c++) {
                        let b = grid[r][c];
                        if (b && b.active) {
                            let dist = Math.hypot(this.x - b.x, this.y - b.y);
                            if (dist < this.radius * 2) {
                                snapToGrid(this);
                                return;
                            }
                        }
                    }
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius - 1, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function initGame() {
            grid = [];
            score = 0;
            document.getElementById('score').innerText = 0;
            document.getElementById('gameOver').style.display = 'none';
            gameActive = true;
            document.getElementById('highScore').innerText = highScore;

            // Create initial rows
            for (let r = 0; r < 5; r++) {
                let row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    // Staggered grid logic
                    let x = (c * 2 + (r % 2)) * BUBBLE_RADIUS + BUBBLE_RADIUS;
                    let y = r * (BUBBLE_RADIUS * Math.sqrt(3)) + BUBBLE_RADIUS;
                    row.push(new Bubble(x, y, COLORS[Math.floor(Math.random() * COLORS.length)], r, c));
                }
                grid.push(row);
            }

            // Fill rest with nulls
            for (let r = 5; r < 15; r++) {
                grid.push(new Array(GRID_COLS).fill(null));
            }

            prepareNextBubble();
            loop();
        }

        function prepareNextBubble() {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            currentBubble = new Projectile(width / 2, height - 50, angle, color);
            currentBubble.stopped = true; // Wait for shot
        }

        function shoot() {
            if (!gameActive || !currentBubble.stopped) return;
            currentBubble.dx = Math.cos(angle) * 15;
            currentBubble.dy = Math.sin(angle) * 15;
            currentBubble.stopped = false;
        }

        function snapToGrid(p) {
            p.stopped = true;

            // Find closest grid position
            let gridY = Math.round((p.y - BUBBLE_RADIUS) / (BUBBLE_RADIUS * Math.sqrt(3)));
            let xOffset = (gridY % 2) * BUBBLE_RADIUS;
            let gridX = Math.round((p.x - BUBBLE_RADIUS - xOffset) / (BUBBLE_RADIUS * 2));

            // Bounds check
            if (gridX < 0) gridX = 0;
            if (gridX >= GRID_COLS - (gridY % 2)) gridX = GRID_COLS - 1 - (gridY % 2);
            if (gridY < 0) gridY = 0;

            // Ensure array exists
            while (grid.length <= gridY) grid.push(new Array(GRID_COLS).fill(null));

            if (grid[gridY][gridX] && grid[gridY][gridX].active) {
                // Occupied, try find neighbor? Simple hack: just overwrite for now or find empty spot close by
                // Proper solution: proper hex grid snapping
                // For this demo: minimal impact if overlap occasionally
            }

            let x = (gridX * 2 + (gridY % 2)) * BUBBLE_RADIUS + BUBBLE_RADIUS;
            let y = gridY * (BUBBLE_RADIUS * Math.sqrt(3)) + BUBBLE_RADIUS;

            let newBubble = new Bubble(x, y, p.color, gridY, gridX);
            grid[gridY][gridX] = newBubble;

            // Check matches
            let matches = findMatches(newBubble);
            if (matches.length >= 3) {
                removeBubbles(matches);
                dropFloatingBubbles();
            }

            // Check Game Over
            if (gridY >= 14) {
                gameOver();
            } else {
                prepareNextBubble();
            }
        }

        function findMatches(startNode) {
            let matches = [];
            let queue = [startNode];
            let visited = new Set();
            visited.add(startNode);
            matches.push(startNode);

            let color = startNode.color;

            let head = 0;
            while (head < queue.length) {
                let current = queue[head++];
                let neighbors = getNeighbors(current);

                for (let n of neighbors) {
                    if (!visited.has(n) && n.color === color) {
                        visited.add(n);
                        matches.push(n);
                        queue.push(n);
                    }
                }
            }
            return matches;
        }

        function getNeighbors(b) {
            let neighbors = [];
            let dirs = [
                [0, -1], [0, 1], // Left, Right
                [-1, -1], [-1, 0], // Top Left, Top Right (even rows)
                [1, -1], [1, 0]    // Bottom Left, Bottom Right
            ];

            if (b.r % 2 === 1) { // Odd rows
                dirs = [
                    [0, -1], [0, 1],
                    [-1, 0], [-1, 1],
                    [1, 0], [1, 1]
                ];
            }

            for (let d of dirs) {
                let nr = b.r + d[0];
                let nc = b.c + d[1];

                if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[nr].length) {
                    let neighbor = grid[nr][nc];
                    if (neighbor && neighbor.active) {
                        neighbors.push(neighbor);
                    }
                }
            }
            return neighbors;
        }

        function removeBubbles(bubbles) {
            bubbles.forEach(b => {
                b.active = false;
                grid[b.r][b.c] = null;
                score += 10;

                // Particles
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: b.x, y: b.y,
                        dx: (Math.random() - 0.5) * 5,
                        dy: (Math.random() - 0.5) * 5,
                        life: 20,
                        color: b.color
                    });
                }
            });
            document.getElementById('score').innerText = score;
        }

        function dropFloatingBubbles() {
            // Find all bubbles connected to ceiling (row 0)
            let connected = new Set();
            let queue = [];

            // Add all active row 0 bubbles
            for (let c = 0; c < (grid[0] ? grid[0].length : 0); c++) {
                if (grid[0][c] && grid[0][c].active) {
                    queue.push(grid[0][c]);
                    connected.add(grid[0][c]);
                }
            }

            let head = 0;
            while (head < queue.length) {
                let curr = queue[head++];
                let neighbors = getNeighbors(curr);
                for (let n of neighbors) {
                    if (!connected.has(n)) {
                        connected.add(n);
                        queue.push(n);
                    }
                }
            }

            // Remove unconnected
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    let b = grid[r][c];
                    if (b && b.active && !connected.has(b)) {
                        // Drop
                        b.active = false;
                        grid[r][c] = null;
                        score += 20; // Bonus
                        // Particles
                        for (let i = 0; i < 5; i++) {
                            particles.push({
                                x: b.x, y: b.y,
                                dx: (Math.random() - 0.5) * 5,
                                dy: (Math.random() + 1) * 5, // Fall down
                                life: 30,
                                color: b.color
                            });
                        }
                    }
                }
            }
            document.getElementById('score').innerText = score;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('finalScore').innerText = score;
            document.getElementById('modalHighScore').innerText = highScore;

            const gameOverTitle = document.getElementById('gameOverTitle');
            const highScoreMsg = document.getElementById('highScoreMsg');

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('bubbleShooterHighScore', highScore);
                document.getElementById('highScore').innerText = highScore;
                document.getElementById('modalHighScore').innerText = highScore;
                gameOverTitle.textContent = 'üéâ AMAZING! üéâ';
                highScoreMsg.style.display = 'block';
            } else {
                gameOverTitle.textContent = 'GAME OVER';
                highScoreMsg.style.display = 'none';
            }

            document.getElementById('gameOver').style.display = 'flex';
        }

        function loop() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, width, height);

            // Draw Grid
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    if (grid[r][c]) grid[r][c].draw();
                }
            }

            // Draw Shooter Line
            ctx.beginPath();
            ctx.moveTo(width / 2, height - 50);
            ctx.lineTo(width / 2 + Math.cos(angle) * 50, height - 50 + Math.sin(angle) * 50);
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw Current Bubble
            if (currentBubble) {
                if (!currentBubble.stopped) currentBubble.update();
                else {
                    // Update angle based on mouse/touch
                    // Done in event listeners
                }
                currentBubble.draw();
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
                if (p.life <= 0) particles.splice(i, 1);
            }

            requestAnimationFrame(loop);
        }

        // Inputs
        function handleInput(x, y) {
            let dx = x - width / 2;
            let dy = y - (height - 50);
            angle = Math.atan2(dy, dx);
            // Constrain angle
            if (angle > -0.2) angle = -0.2;
            if (angle < -Math.PI + 0.2) angle = -Math.PI + 0.2;
        }

        canvas.addEventListener('mousemove', e => {
            let rect = canvas.getBoundingClientRect();
            handleInput(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('click', shoot);

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            let rect = canvas.getBoundingClientRect();
            handleInput(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            shoot();
        });

        initGame();
    </script>
</body>

</html>