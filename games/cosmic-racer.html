<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Racer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #scoreBoard { color: #0ff; font-size: 24px; padding: 20px; text-shadow: 0 0 10px #0ff; }
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; pointer-events: auto; z-index: 10; }
        h1 { font-size: 3rem; margin-bottom: 20px; background: linear-gradient(to right, #f0f, #0ff); -webkit-background-clip: text; color: transparent; }
        .btn { background: linear-gradient(45deg, #00c6ff, #0072ff); border: none; padding: 15px 40px; color: white; font-size: 1.5rem; margin: 10px; border-radius: 30px; cursor: pointer; box-shadow: 0 0 20px rgba(0, 114, 255, 0.5); transition: transform 0.2s; }
        .btn:hover { transform: scale(1.1); }
        .selection { display: flex; gap: 20px; margin-bottom: 30px; }
        .vehicle-card { background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; border: 2px solid transparent; cursor: pointer; text-align: center; transition: all 0.3s; }
        .vehicle-card.selected { border-color: #0ff; background: rgba(0, 255, 255, 0.2); transform: scale(1.05); }
        .vehicle-icon { font-size: 3rem; margin-bottom: 10px; }
        #controls { display: none; width: 100%; padding: 20px; justify-content: space-between; pointer-events: auto; }
        .touch-btn { width: 80px; height: 80px; border-radius: 50%; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5); display: flex; align-items: center; justify-content: center; font-size: 2rem; color: white; user-select: none; }
        .touch-btn:active { background: rgba(255,255,255,0.4); }

        @media (max-width: 768px) {
            #controls { display: flex; }
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="scoreBoard">
            SCORE: <span id="scoreVal">0</span><br>
            SPEED: <span id="speedVal">0</span> km/s
        </div>
        <div id="controls">
            <div class="touch-btn" id="btnLeft">‚Üê</div>
            <div class="touch-btn" id="btnRight">‚Üí</div>
        </div>
    </div>

    <div id="menu">
        <h1>COSMIC RACER</h1>
        <p>Select Your Vehicle</p>
        <div class="selection">
            <div class="vehicle-card selected" id="selectCar" onclick="selectVehicle('car')">
                <div class="vehicle-icon">üèéÔ∏è</div>
                <div>Stellar Car</div>
                <div style="font-size: 0.8rem; color: #aaa;">High Stability</div>
            </div>
            <div class="vehicle-card" id="selectBike" onclick="selectVehicle('bike')">
                <div class="vehicle-icon">üèçÔ∏è</div>
                <div>Void Bike</div>
                <div style="font-size: 0.8rem; color: #aaa;">High Agility</div>
            </div>
        </div>
        <button class="btn" onclick="startGame()">LAUNCH</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let gameActive = false;
        let score = 0;
        let speed = 0;
        let distance = 0;
        let vehicleType = 'car'; // car or bike

        // Game State
        let playerX = 0; // -1 to 1
        let road = [];
        const segmentLength = 200;
        const rumbleLength = 3;
        const lanes = 3;
        let obstacles = [];
        let stars = [];

        // Player settings
        let maxSpeed = 0;
        let accel = 0;
        let handling = 0;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        function selectVehicle(type) {
            vehicleType = type;
            document.getElementById('selectCar').classList.toggle('selected', type === 'car');
            document.getElementById('selectBike').classList.toggle('selected', type === 'bike');
        }

        function init() {
            // Stats based on vehicle
            if (vehicleType === 'car') {
                maxSpeed = 12000;
                accel = 100;
                handling = 0.08;
            } else {
                maxSpeed = 15000;
                accel = 150;
                handling = 0.12;
            }

            playerX = 0;
            speed = 0;
            score = 0;
            distance = 0;
            obstacles = [];
            gameActive = true;
            document.getElementById('menu').style.display = 'none';

            // Init stars
            stars = [];
            for(let i=0; i<500; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    z: Math.random() * 2 // Speed factor
                });
            }

            lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function startGame() {
            init();
        }

        // Input Handling
        const keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false };
        document.addEventListener('keydown', e => keys[e.key] = true);
        document.addEventListener('keyup', e => keys[e.key] = false);

        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); keys.ArrowLeft = true; });
        btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowLeft = false; });
        btnLeft.addEventListener('mousedown', (e) => { e.preventDefault(); keys.ArrowLeft = true; });
        btnLeft.addEventListener('mouseup', (e) => { e.preventDefault(); keys.ArrowLeft = false; });

        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); keys.ArrowRight = true; });
        btnRight.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowRight = false; });
        btnRight.addEventListener('mousedown', (e) => { e.preventDefault(); keys.ArrowRight = true; });
        btnRight.addEventListener('mouseup', (e) => { e.preventDefault(); keys.ArrowRight = false; });


        // Math Utils
        function project(p, cameraX, cameraY, cameraZ, cameraDepth) {
            const scale = cameraDepth / (p.z - cameraZ);
            const x = (1 + scale * (p.x - cameraX)) * width / 2;
            const y = (1 - scale * (p.y - cameraY)) * height / 2;
            const w = scale * width * 2; // Road width at this point
            return { x, y, w, scale };
        }

        function drawQuad(color, x1, y1, w1, x2, y2, w2) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1 - w1, y1);
            ctx.lineTo(x2 - w2, y2);
            ctx.lineTo(x2 + w2, y2);
            ctx.lineTo(x1 + w1, y1);
            ctx.fill();
        }

        let lastTime = 0;
        let trackLength = 0;

        function update(dt) {
            // Speed and Movement
            if (keys.ArrowUp) speed += accel; // Manual accelerate
            else speed += accel * 0.5; // Auto accelerate slightly

            if (keys.ArrowDown) speed -= accel * 2; // Brake

            // Steering
            if (keys.ArrowLeft) playerX -= handling * (speed / maxSpeed);
            if (keys.ArrowRight) playerX += handling * (speed / maxSpeed);

            // Friction and Limits
            speed *= 0.98; // Drag
            playerX = Math.max(-1.5, Math.min(1.5, playerX)); // Road bounds
            speed = Math.max(0, Math.min(maxSpeed, speed));

            distance += speed * dt;
            score += Math.floor(speed * dt * 0.01);

            // Spawn Obstacles
            if (Math.random() < 0.02 + (speed/maxSpeed)*0.05) {
                // Determine lane
                const lane = (Math.floor(Math.random() * 3) - 1) * 0.6; // -0.6, 0, 0.6
                obstacles.push({
                    x: lane, // -1 to 1 range
                    z: distance + 20000, // Spawn far ahead
                    type: Math.random() > 0.5 ? 'asteroid' : 'debris'
                });
            }

            // Remove passed obstacles
            obstacles = obstacles.filter(o => o.z > distance - 200);

            // Collision
            obstacles.forEach(o => {
                if (o.z < distance + 200 && o.z > distance) {
                    // Check width collision
                    // Player width approx 0.3
                    if (Math.abs(playerX - o.x) < 0.4) {
                        gameOver();
                    }
                }
            });

            // Stars
            stars.forEach(s => {
                s.y += (speed * 0.0001) * s.z;
                if(s.y > height) {
                    s.y = 0;
                    s.x = Math.random() * width;
                }
            });
        }

        function render() {
            // Clear
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, width, height);

            // Draw Stars
            ctx.fillStyle = "#fff";
            stars.forEach(s => {
                ctx.globalAlpha = 0.5 + Math.random() * 0.5;
                const size = Math.max(0.5, (speed/maxSpeed)*2);
                ctx.beginPath();
                ctx.arc(s.x, s.y, size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw Sun/Planet in background
            const sunY = height * 0.3;
            const sunX = width * 0.5 + (playerX * -50);
            const grd = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 200);
            grd.addColorStop(0, "#f0f");
            grd.addColorStop(1, "transparent");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, width, height * 0.6);


            // Pseudo-3D Road Render
            const fov = 100;
            const cameraHeight = 1000;
            const drawDistance = 300;
            const segmentZ = 100;

            // We draw from back to front
            // Actually, for a simple grid effect, we can just draw lines
            // But let's do a proper segment loop

            const baseZ = Math.floor(distance / segmentZ) * segmentZ;
            const offsetZ = - (distance % segmentZ);

            let clipBottom = height;

            for (let n = drawDistance; n > 0; n--) {
                const z = n * segmentZ + offsetZ;
                if (z < 1) continue;

                const scale = fov / z;
                const y = height / 2 + (cameraHeight * scale);

                // Curve calculation could go here (omitted for simplicity)
                const curve = 0;

                const w = width * 2 * scale;
                const x = width / 2 - (playerX * width * scale); // Parallax effect on road

                // Draw Ground/Road segment
                // Alternating colors
                const totalZ = baseZ + n * segmentZ;
                const colorC = (Math.floor(totalZ / segmentZ) % 2) ? '#220033' : '#110022';

                // Only draw if visible
                if (y >= clipBottom) continue;

                // Calculate previous segment (closer to camera) to fill gap
                // Actually easier to just draw rects or lines
                // Let's draw a horizontal strip
                const nextZ = (n - 1) * segmentZ + offsetZ;
                const nextScale = fov / nextZ;
                const nextY = height / 2 + (cameraHeight * nextScale);

                if (nextY > y) {
                    ctx.fillStyle = colorC;
                    ctx.fillRect(0, y, width, nextY - y);

                    // Road borders
                    const roadW = w * 0.5; // Road width factor
                    const nextRoadW = width * 2 * nextScale * 0.5;
                    const nextX = width / 2 - (playerX * width * nextScale);

                    // We need trapezoids for the road
                    // Center road
                    drawQuad((Math.floor(totalZ / segmentZ) % 2) ? 'rgba(0,255,255,0.1)' : 'rgba(0,255,255,0.2)',
                             x, y, roadW,
                             nextX, nextY, nextRoadW);
                }
            }

            // Horizon Line
            ctx.fillStyle = "#000";
            // ctx.fillRect(0, height/2, width, 2);

            // Draw Obstacles (Back to Front sorted)
            // Filter visible
            const visibleObstacles = obstacles.filter(o => o.z > distance && o.z < distance + 20000);
            visibleObstacles.sort((a, b) => b.z - a.z);

            visibleObstacles.forEach(o => {
                const relZ = o.z - distance;
                const scale = fov / relZ;
                const y = height / 2 + (cameraHeight * scale);
                const ox = width / 2 + (o.x * width * 2 * scale) - (playerX * width * scale);

                const size = 5000 * scale;

                if (scale > 0 && y < height) {
                    // Draw Asteroid
                    ctx.save();
                    ctx.translate(ox, y - size);
                    ctx.fillStyle = "#888";
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI*2);
                    ctx.fill();
                    // Detail
                    ctx.fillStyle = "#555";
                    ctx.beginPath();
                    ctx.arc(-size*0.3, -size*0.3, size*0.2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw Player
            // Always at bottom center
            const pScale = 1;
            const pY = height - 150;
            const pX = width / 2;

            ctx.save();
            ctx.translate(pX, pY);

            // Sway
            const sway = Math.sin(Date.now() / 100) * 5;
            ctx.rotate((playerX * 0.5 + sway * 0.001));

            if (vehicleType === 'car') {
                // Draw Car
                ctx.fillStyle = "#f00";
                ctx.shadowBlur = 20;
                ctx.shadowColor = "#f00";
                ctx.fillRect(-60, 0, 120, 60); // Body
                ctx.fillStyle = "#0ff"; // Glass
                ctx.fillRect(-50, -30, 100, 30);
                // Engine glow
                ctx.fillStyle = "#0ff";
                ctx.fillRect(-40, 60, 20, 10);
                ctx.fillRect(20, 60, 20, 10);
            } else {
                // Draw Bike
                ctx.fillStyle = "#ff0";
                ctx.shadowBlur = 20;
                ctx.shadowColor = "#ff0";
                ctx.fillRect(-20, -20, 40, 100); // Body
                ctx.fillStyle = "#fff"; // Head
                ctx.fillRect(-15, -40, 30, 20);
                // Engine glow
                ctx.fillStyle = "#0ff";
                ctx.beginPath();
                ctx.arc(0, 80, 10, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.restore();

            // Speed lines
            if (speed > maxSpeed * 0.8) {
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i=0; i<10; i++) {
                    const lx = Math.random() * width;
                    const ly = Math.random() * height;
                    ctx.moveTo(lx, ly);
                    ctx.lineTo(lx - (lx-width/2)*0.1, ly - (ly-height/2)*0.1);
                }
                ctx.stroke();
            }

            // UI
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('speedVal').innerText = Math.floor(speed / 100);
        }

        function gameOver() {
            gameActive = false;
            alert("GAME OVER! Score: " + score);
            document.getElementById('menu').style.display = 'flex';
        }

        function loop() {
            if (!gameActive) return;
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            update(dt);
            render();
            requestAnimationFrame(loop);
        }

    </script>
</body>
</html>
