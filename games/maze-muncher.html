<!DOCTYPE html>
<html class="dark" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Maze Muncher - Ultimate Edition</title>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Spline+Sans:wght@400;500;600;700&display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"/>
<script>
  tailwind.config = {
    darkMode: "class",
    theme: {
      extend: {
        colors: {
          "primary": "#f4af25",
          "background-light": "#f8f7f5",
          "background-dark": "#221c10",
        },
        fontFamily: {
          "display": ["Spline Sans", "sans-serif"]
        },
        borderRadius: {"DEFAULT": "1rem", "lg": "2rem", "xl": "3rem", "full": "9999px"},
      },
    },
  }
</script>
<style>
  .material-symbols-outlined {
    font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24;
  }
  .maze-grid {
    display: grid;
    grid-template-columns: repeat(15, 1fr);
    grid-template-rows: repeat(15, 1fr);
    width: 100%;
    aspect-ratio: 1 / 1;
    gap: 2px;
    padding: 4px;
  }
  .maze-wall {
    background-color: #3b301a;
    transition: background-color 0.3s;
  }
  .maze-path {
    background-color: transparent;
    position: relative;
  }
  .maze-dot {
    position: relative;
  }
  .maze-dot::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 4px;
    height: 4px;
    background-color: #f4af25;
    border-radius: 9999px;
    opacity: 0.7;
    animation: pulse 2s infinite;
  }
  .maze-dot.collected::after {
    display: none;
  }
  .maze-powerup::after {
    width: 10px !important;
    height: 10px !important;
    box-shadow: 0 0 10px #f4af25;
    animation: powerup-pulse 1s infinite;
  }
  .maze-bonus {
    position: relative;
  }
  .maze-bonus::before {
    content: 'üçí';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    animation: bounce 1s infinite;
  }
  .maze-bonus.collected::before {
    display: none;
  }
  @keyframes pulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
  }
  @keyframes powerup-pulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.3); }
  }
  @keyframes bounce {
    0%, 100% { transform: translate(-50%, -50%) translateY(0); }
    50% { transform: translate(-50%, -50%) translateY(-3px); }
  }
  body {
    min-height: max(884px, 100dvh);
  }
  .player {
    transition: top 0.12s ease-out, left 0.12s ease-out;
    z-index: 10;
  }
  .ghost {
    position: absolute;
    width: 6.66%;
    height: 6.66%;
    transition: top 0.2s linear, left 0.2s linear;
    z-index: 9;
  }
  .ghost.frightened {
    filter: brightness(0.5) sepia(1) hue-rotate(180deg) saturate(3);
    animation: frightenedShake 0.2s infinite;
  }
  @keyframes frightenedShake {
    0%, 100% { transform: translateX(0); }
    50% { transform: translateX(2px); }
  }
  .ghost-body {
    width: 100%;
    height: 85%;
    border-radius: 50% 50% 0 0;
    position: relative;
    background: var(--ghost-color);
  }
  .ghost-skirt {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 30%;
    background: var(--ghost-color);
    display: flex;
  }
  .ghost-skirt-wave {
    flex: 1;
    height: 100%;
    background: var(--ghost-color);
    border-radius: 0 0 50% 50%;
  }
  .ghost-eyes {
    position: absolute;
    top: 35%;
    left: 15%;
    width: 70%;
    height: 25%;
    display: flex;
    gap: 15%;
  }
  .ghost-eye {
    width: 35%;
    height: 100%;
    background: white;
    border-radius: 50%;
    position: relative;
  }
  .ghost-pupil {
    position: absolute;
    width: 50%;
    height: 50%;
    background: #0066ff;
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    transition: all 0.1s;
  }
  .pacman {
    width: 100%;
    height: 100%;
    background: #f4af25;
    border-radius: 50%;
    position: relative;
    overflow: hidden;
  }
  .pacman::before {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border: 50% solid transparent;
    border-right: 0;
    border-left: 50% solid #221c10;
    top: 0;
    left: 0;
    transform-origin: 100% 50%;
    animation: chomp 0.3s infinite;
  }
  @keyframes chomp {
    0%, 100% {
      transform: rotate(0deg);
      clip-path: polygon(100% 0, 0 50%, 100% 100%);
    }
    50% {
      transform: rotate(0deg);
      clip-path: polygon(100% 20%, 0 50%, 100% 80%);
    }
  }
  .pacman.moving::before {
    animation: chomp 0.2s infinite;
  }
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    z-index: 100;
    align-items: center;
    justify-content: center;
    overflow-y: auto;
  }
  .modal.active {
    display: flex;
    animation: fadeIn 0.3s;
  }
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  .combo-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: #f4af25;
    animation: comboFloat 1s forwards;
    pointer-events: none;
    z-index: 50;
  }
  @keyframes comboFloat {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -100%) scale(1.5); }
  }
  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #f4af25;
    border-radius: 50%;
    pointer-events: none;
    animation: particleFloat 0.5s forwards;
  }
  @keyframes particleFloat {
    0% { opacity: 1; transform: translate(0, 0) scale(1); }
    100% { opacity: 0; transform: translate(var(--x), var(--y)) scale(0); }
  }
  .shake {
    animation: shake 0.3s;
  }
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }
  .progress-bar {
    height: 4px;
    background: rgba(244, 175, 37, 0.3);
    border-radius: 2px;
    overflow: hidden;
  }
  .progress-fill {
    height: 100%;
    background: #f4af25;
    transition: width 0.3s;
  }
  .star {
    color: #f4af25;
    font-size: 32px;
    display: inline-block;
    animation: starAppear 0.5s forwards;
    opacity: 0;
  }
  @keyframes starAppear {
    0% { opacity: 0; transform: scale(0) rotate(0deg); }
    100% { opacity: 1; transform: scale(1) rotate(360deg); }
  }
  .level-btn {
    min-width: 60px;
    padding: 12px;
    border-radius: 8px;
    font-weight: bold;
    transition: all 0.2s;
  }
  .level-btn:hover {
    transform: scale(1.05);
  }
  .level-btn.locked {
    opacity: 0.4;
    cursor: not-allowed;
  }
</style>
</head>
<body class="bg-background-light dark:bg-background-dark font-display">
<div class="relative flex h-screen w-full max-w-md mx-auto flex-col overflow-hidden">
  <!-- Top App Bar -->
  <div class="absolute top-0 left-0 right-0 z-20 p-4">
    <div class="flex items-center justify-between mb-2">
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-primary text-2xl">trophy</span>
        <span id="score" class="text-white text-xl font-bold">0</span>
        <span id="combo" class="text-primary text-sm font-bold ml-2" style="display:none;">x2</span>
      </div>
      <div class="flex gap-2">
        <button id="soundBtn" class="flex items-center justify-center rounded-full size-10 bg-black/30 text-white backdrop-blur-sm">
          <span class="material-symbols-outlined text-xl">volume_up</span>
        </button>
        <button id="pauseBtn" class="flex items-center justify-center rounded-full size-10 bg-black/30 text-white backdrop-blur-sm">
          <span class="material-symbols-outlined text-xl">pause</span>
        </button>
      </div>
      <div id="lives" class="flex items-center justify-end gap-1.5">
        <span class="material-symbols-outlined text-primary text-2xl">favorite</span>
        <span class="material-symbols-outlined text-primary text-2xl">favorite</span>
        <span class="material-symbols-outlined text-primary text-2xl">favorite</span>
      </div>
    </div>
    <div class="flex items-center justify-between text-white text-xs mb-1">
      <span>Level <span id="levelDisplay">1</span>/20</span>
      <span>High: <span id="highScore">0</span></span>
      <span>Time: <span id="timer">0</span>s</span>
    </div>
    <div class="progress-bar">
      <div id="progressFill" class="progress-fill" style="width: 0%"></div>
    </div>
  </div>

  <!-- Game Board -->
  <div class="flex-grow flex items-center justify-center p-4 pt-24">
    <div class="relative w-full aspect-square" id="gameContainer">
      <div id="mazeGrid" class="maze-grid rounded-lg bg-background-dark/50">
        <!-- Maze will be generated here -->
      </div>
      <!-- Player Character -->
      <div id="player" class="player absolute w-[6.66%] h-[6.66%]">
        <div class="pacman"></div>
      </div>
      <!-- Ghosts will be added here -->
    </div>
  </div>

  <!-- Controls -->
  <div class="relative flex items-center justify-center p-8 pb-12">
    <div class="relative w-48 h-48">
      <div class="absolute inset-0 bg-black/20 rounded-full backdrop-blur-sm"></div>
      <button id="upBtn" class="absolute top-0 left-1/2 -translate-x-1/2 -translate-y-2 flex items-center justify-center rounded-full size-16 bg-black/40 text-white active:bg-primary">
        <span class="material-symbols-outlined text-4xl">keyboard_arrow_up</span>
      </button>
      <button id="downBtn" class="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-2 flex items-center justify-center rounded-full size-16 bg-black/40 text-white active:bg-primary">
        <span class="material-symbols-outlined text-4xl">keyboard_arrow_down</span>
      </button>
      <button id="leftBtn" class="absolute left-0 top-1/2 -translate-y-1/2 -translate-x-2 flex items-center justify-center rounded-full size-16 bg-black/40 text-white active:bg-primary">
        <span class="material-symbols-outlined text-4xl">keyboard_arrow_left</span>
      </button>
      <button id="rightBtn" class="absolute right-0 top-1/2 -translate-y-1/2 translate-x-2 flex items-center justify-center rounded-full size-16 bg-black/40 text-white active:bg-primary">
        <span class="material-symbols-outlined text-4xl">keyboard_arrow_right</span>
      </button>
    </div>
  </div>

  <!-- Start Screen Modal -->
  <div id="startModal" class="modal active">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4">
      <h1 class="text-primary text-4xl font-bold mb-2">MAZE MUNCHER</h1>
      <p class="text-primary/70 text-sm mb-6">Ultimate Edition</p>
      <div class="text-white text-left mb-6 space-y-2">
        <p class="text-sm">üéÆ 20 Unique Levels</p>
        <p class="text-sm">üëæ Smart AI Ghosts</p>
        <p class="text-sm">‚ö° Power-ups & Bonuses</p>
        <p class="text-sm">üèÜ High Score Tracking</p>
      </div>
      <button id="startBtn" class="bg-primary text-background-dark px-8 py-3 rounded-full font-bold text-lg w-full mb-3">Start from Level 1</button>
      <button id="levelSelectBtn" class="bg-black/40 text-white px-8 py-3 rounded-full font-bold text-lg w-full mb-3">Select Level</button>
      <button id="tutorialBtn" class="bg-black/40 text-white px-8 py-3 rounded-full font-bold text-sm w-full">How to Play</button>
    </div>
  </div>

  <!-- Level Selection Modal -->
  <div id="levelSelectModal" class="modal">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4 max-h-[80vh] overflow-y-auto">
      <h2 class="text-primary text-2xl font-bold mb-4">Select Level</h2>
      <p class="text-white/70 text-sm mb-4">Choose your starting level</p>
      <div id="levelGrid" class="grid grid-cols-5 gap-2 mb-6">
        <!-- Level buttons will be generated here -->
      </div>
      <button id="closeLevelSelectBtn" class="bg-black/40 text-white px-8 py-3 rounded-full font-bold text-lg w-full">Back</button>
    </div>
  </div>

  <!-- Tutorial Modal -->
  <div id="tutorialModal" class="modal">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4 max-h-[80vh] overflow-y-auto">
      <h2 class="text-primary text-2xl font-bold mb-4">How to Play</h2>
      <div class="text-white text-left space-y-3 text-sm">
        <p><strong>üéØ Goal:</strong> Collect all dots to complete each level</p>
        <p><strong>üïπÔ∏è Controls:</strong> Arrow keys, WASD, or swipe gestures</p>
        <p><strong>üëæ Ghosts:</strong> Avoid them or you'll lose a life</p>
        <p><strong>‚ö° Big Dots:</strong> Eat these to turn ghosts blue and eat them!</p>
        <p><strong>üçí Bonus:</strong> Collect fruits for extra points</p>
        <p><strong>üîÑ Combo:</strong> Collect dots quickly for score multipliers</p>
        <p><strong>‚≠ê Stars:</strong> Earn 1-3 stars based on performance</p>
        <p><strong>üí∞ Scoring:</strong></p>
        <ul class="ml-4 space-y-1">
          <li>‚Ä¢ Dot: 10 points</li>
          <li>‚Ä¢ Power-up: 50 points</li>
          <li>‚Ä¢ Ghost: 200 points</li>
          <li>‚Ä¢ Bonus: 100 points</li>
        </ul>
        <p><strong>üéÆ Ghost Behavior:</strong></p>
        <ul class="ml-4 space-y-1">
          <li>‚Ä¢ üî¥ Red: Chases you directly</li>
          <li>‚Ä¢ ü©∑ Pink: Ambushes your path</li>
          <li>‚Ä¢ ü©µ Cyan: Moves randomly</li>
          <li>‚Ä¢ üü† Orange: Shy, runs when close</li>
        </ul>
      </div>
      <button id="closeTutorialBtn" class="bg-primary text-background-dark px-8 py-3 rounded-full font-bold text-lg w-full mt-6">Got It!</button>
    </div>
  </div>

  <!-- Pause Modal -->
  <div id="pauseModal" class="modal">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4">
      <h2 class="text-primary text-3xl font-bold mb-4">PAUSED</h2>
      <div class="text-white mb-6 space-y-2">
        <p>Level: <span id="pauseLevel">1</span></p>
        <p>Score: <span id="pauseScore">0</span></p>
      </div>
      <button id="resumeBtn" class="bg-primary text-background-dark px-8 py-3 rounded-full font-bold text-lg w-full mb-3">Resume</button>
      <button id="quitBtn" class="bg-red-500 text-white px-8 py-3 rounded-full font-bold text-lg w-full">Quit to Menu</button>
    </div>
  </div>

  <!-- Level Complete Modal -->
  <div id="levelCompleteModal" class="modal">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4">
      <h2 class="text-primary text-3xl font-bold mb-4">LEVEL COMPLETE!</h2>
      <div id="starsContainer" class="mb-4">
        <!-- Stars will be added here -->
      </div>
      <div class="text-white mb-6 space-y-2">
        <p>Score: <span id="levelScore">0</span></p>
        <p>Time: <span id="levelTime">0</span>s</p>
        <p>Bonus: <span id="timeBonus">0</span></p>
      </div>
      <button id="nextLevelBtn" class="bg-primary text-background-dark px-8 py-3 rounded-full font-bold text-lg w-full">Next Level</button>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div id="gameOverModal" class="modal">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4">
      <h2 class="text-red-500 text-3xl font-bold mb-4">GAME OVER</h2>
      <div class="text-white mb-6 space-y-2">
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>High Score: <span id="gameOverHighScore">0</span></p>
      </div>
      <button id="restartBtn" class="bg-primary text-background-dark px-8 py-3 rounded-full font-bold text-lg w-full mb-3">Try Again</button>
      <button id="menuBtn" class="bg-black/40 text-white px-8 py-3 rounded-full font-bold text-lg w-full">Main Menu</button>
    </div>
  </div>

  <!-- Victory Modal -->
  <div id="victoryModal" class="modal">
    <div class="bg-background-dark p-8 rounded-xl text-center max-w-sm mx-4">
      <h2 class="text-primary text-3xl font-bold mb-4">üéâ VICTORY! üéâ</h2>
      <p class="text-white mb-4">You completed all 20 levels!</p>
      <div class="text-white mb-6 space-y-2">
        <p>Total Score: <span id="victoryScore">0</span></p>
        <p>Total Time: <span id="totalTime">0</span>s</p>
        <p class="text-primary font-bold text-xl mt-4">NEW HIGH SCORE!</p>
      </div>
      <button id="playAgainBtn" class="bg-primary text-background-dark px-8 py-3 rounded-full font-bold text-lg w-full">Play Again</button>
    </div>
  </div>
</div>

<script>
// ============================================
// GAME CONSTANTS & CONFIGURATION
// ============================================
const CONFIG = {
  GRID_SIZE: 15,
  CELL_SIZE: 6.66,
  GHOST_SPEED_BASE: 400,
  GHOST_SPEED_MULTIPLIER: 0.95,
  PLAYER_SPEED: 120,
  POWER_UP_DURATION: 8000,
  BONUS_SPAWN_TIME: 15000,
  BONUS_DURATION: 10000,
  COMBO_TIMEOUT: 1500,
  POINTS: {
    DOT: 10,
    POWER_UP: 50,
    GHOST: 200,
    BONUS: 100
  },
  // ‚úÖ FIXED SPAWN POSITIONS
  PLAYER_START: { row: 1, col: 1 },  // Top-left corner
  GHOST_START: { row: 7, col: 7 }     // Center of maze
};

// 20 UNIQUE MAZE LAYOUTS (same as before)
const MAZE_LEVELS = [
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,3,1,0,1,3,1,1,1,0,1],
    [1,0,0,0,1,0,0,2,1,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,1,0,1,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,3,0,0,0,0,0,0,0,3,1,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,1,3,0,0,0,0,0,0,0,3,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,3,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,0,2,0,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,3,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,2,1,3,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,1,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,0,0,0,1,1,0,1,0,1],
    [1,0,1,0,1,3,0,1,0,3,1,0,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,0,2,0,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,3,0,1,0,3,1,0,1,0,1],
    [1,0,1,0,1,1,0,0,0,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,1,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,0,1,1,1,0,1,0,1,1,1],
    [1,0,0,0,0,0,1,3,1,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,2,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,3,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,3,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,1,3,1,0,1,0,1,0,1,3,1,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
    [1,0,1,3,1,0,1,0,1,0,1,3,1,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,1,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,1,0,1,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,1,1,1,1],
    [1,0,0,0,1,3,0,2,0,3,1,0,0,0,1],
    [1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,1,0,1,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,1,1,0,1,1,1,0,0,0,1],
    [1,0,1,0,1,3,0,0,0,3,1,0,1,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,0,2,0,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,1,0,1,3,0,0,0,3,1,0,1,0,1],
    [1,0,0,0,1,1,1,0,1,1,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,2,1,3,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,3,0,1,0,0,0,1,0,3,1,0,1],
    [1,0,1,1,0,1,1,1,1,1,0,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,1,1,0,0,0,0,2,0,0,0,0,1,1,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,1,1,1,1,0,1,1,0,1],
    [1,0,1,3,0,1,0,0,0,1,0,3,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,1,0,1,3,1],
    [1,0,1,0,1,1,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,0,2,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,3,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,1,3,0,0,0,3,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,1,2,1,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,3,0,0,0,3,1,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,1,3,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,3,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,2,1,3,1,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,3,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ]
];

// ============================================
// GAME STATE
// ============================================
const gameState = {
  score: 0,
  highScore: localStorage.getItem('mazeHighScore') || 0,
  maxLevelReached: parseInt(localStorage.getItem('maxLevelReached')) || 1,
  lives: 3,
  level: 1,
  isPaused: false,
  isGameOver: false,
  playerPos: { ...CONFIG.PLAYER_START },  // ‚úÖ USING CONFIG
  direction: 'right',
  isMoving: false,
  totalDots: 0,
  collectedDots: 0,
  powerUpActive: false,
  powerUpTimer: null,
  bonusActive: false,
  bonusTimer: null,
  bonusSpawnTimer: null,
  combo: 0,
  comboTimer: null,
  gameTimer: 0,
  gameTimerInterval: null,
  totalTime: 0,
  soundEnabled: true,
  ghosts: []
};

// Ghost class and other code continues...
// (I'll include the critical parts)

class Ghost {
  constructor(id, color, startPos, behavior) {
    this.id = id;
    this.color = color;
    this.pos = { ...startPos };
    this.behavior = behavior;
    this.frightened = false;
    this.element = null;
    this.moveInterval = null;
    this.init();
  }

  init() {
    this.element = document.createElement('div');
    this.element.className = 'ghost';
    this.element.style.setProperty('--ghost-color', this.color);
    this.element.innerHTML = `
      <div class="ghost-body">
        <div class="ghost-eyes">
          <div class="ghost-eye"><div class="ghost-pupil"></div></div>
          <div class="ghost-eye"><div class="ghost-pupil"></div></div>
        </div>
      </div>
      <div class="ghost-skirt">
        <div class="ghost-skirt-wave"></div>
        <div class="ghost-skirt-wave"></div>
        <div class="ghost-skirt-wave"></div>
      </div>
    `;
    document.getElementById('gameContainer').appendChild(this.element);
    this.updatePosition();
    this.startMoving();
  }

  updatePosition() {
    this.element.style.top = (this.pos.row * CONFIG.CELL_SIZE) + '%';
    this.element.style.left = (this.pos.col * CONFIG.CELL_SIZE) + '%';
  }

  startMoving() {
    const levelMultiplier = Math.pow(CONFIG.GHOST_SPEED_MULTIPLIER, gameState.level - 1);
    const ghostSpeed = CONFIG.GHOST_SPEED_BASE * levelMultiplier;

    this.moveInterval = setInterval(() => {
      if (!gameState.isPaused && !gameState.isGameOver) {
        this.move();
      }
    }, ghostSpeed);
  }

  move() {
    let newPos = { ...this.pos };

    if (this.frightened) {
      const directions = this.getValidDirections();
      if (directions.length > 0) {
        const dir = directions[Math.floor(Math.random() * directions.length)];
        newPos = this.getNewPosition(dir);
      }
    } else {
      switch (this.behavior) {
        case 'chase': newPos = this.chasePlayer(); break;
        case 'ambush': newPos = this.ambushPlayer(); break;
        case 'random': newPos = this.randomMove(); break;
        case 'shy': newPos = this.shyMove(); break;
      }
    }

    if (isValidPosition(newPos.row, newPos.col)) {
      this.pos = newPos;
      this.updatePosition();
      this.checkCollision();
    }
  }

  chasePlayer() {
    const player = gameState.playerPos;
    const directions = this.getValidDirections();
    let bestDir = null;
    let minDist = Infinity;

    directions.forEach(dir => {
      const newPos = this.getNewPosition(dir);
      const dist = Math.abs(newPos.row - player.row) + Math.abs(newPos.col - player.col);
      if (dist < minDist) {
        minDist = dist;
        bestDir = dir;
      }
    });

    return bestDir ? this.getNewPosition(bestDir) : this.pos;
  }

  ambushPlayer() {
    const player = gameState.playerPos;
    const ahead = 3;
    let targetPos = { ...player };

    switch (gameState.direction) {
      case 'up': targetPos.row -= ahead; break;
      case 'down': targetPos.row += ahead; break;
      case 'left': targetPos.col -= ahead; break;
      case 'right': targetPos.col += ahead; break;
    }

    const directions = this.getValidDirections();
    let bestDir = null;
    let minDist = Infinity;

    directions.forEach(dir => {
      const newPos = this.getNewPosition(dir);
      const dist = Math.abs(newPos.row - targetPos.row) + Math.abs(newPos.col - targetPos.col);
      if (dist < minDist) {
        minDist = dist;
        bestDir = dir;
      }
    });

    return bestDir ? this.getNewPosition(bestDir) : this.pos;
  }

  randomMove() {
    const directions = this.getValidDirections();
    if (directions.length > 0) {
      const dir = directions[Math.floor(Math.random() * directions.length)];
      return this.getNewPosition(dir);
    }
    return this.pos;
  }

  shyMove() {
    const player = gameState.playerPos;
    const dist = Math.abs(this.pos.row - player.row) + Math.abs(this.pos.col - player.col);

    if (dist < 6) {
      const directions = this.getValidDirections();
      let bestDir = null;
      let maxDist = 0;

      directions.forEach(dir => {
        const newPos = this.getNewPosition(dir);
        const d = Math.abs(newPos.row - player.row) + Math.abs(newPos.col - player.col);
        if (d > maxDist) {
          maxDist = d;
          bestDir = dir;
        }
      });

      return bestDir ? this.getNewPosition(bestDir) : this.pos;
    } else {
      return this.chasePlayer();
    }
  }

  getValidDirections() {
    const dirs = ['up', 'down', 'left', 'right'];
    return dirs.filter(dir => {
      const newPos = this.getNewPosition(dir);
      return isValidPosition(newPos.row, newPos.col);
    });
  }

  getNewPosition(direction) {
    const newPos = { ...this.pos };
    switch (direction) {
      case 'up': newPos.row--; break;
      case 'down': newPos.row++; break;
      case 'left': newPos.col--; break;
      case 'right': newPos.col++; break;
    }
    return newPos;
  }

  checkCollision() {
    if (this.pos.row === gameState.playerPos.row && this.pos.col === gameState.playerPos.col) {
      if (this.frightened) {
        playSound('eatGhost');
        addScore(CONFIG.POINTS.GHOST);
        this.respawn();
      } else {
        loseLife();
      }
    }
  }

  setFrightened(value) {
    this.frightened = value;
    if (value) {
      this.element.classList.add('frightened');
    } else {
      this.element.classList.remove('frightened');
    }
  }

  respawn() {
    // ‚úÖ FIXED: Ghosts respawn at CENTER
    this.pos = { ...CONFIG.GHOST_START };
    this.updatePosition();
    this.frightened = false;
    this.element.classList.remove('frightened');
  }

  destroy() {
    if (this.moveInterval) clearInterval(this.moveInterval);
    if (this.element) this.element.remove();
  }
}

// Sound system
const sounds = {
  dot: () => playTone(800, 50),
  powerUp: () => playTone(1200, 200),
  eatGhost: () => playTone(600, 300),
  bonus: () => playTone(1500, 150),
  loseLife: () => playTone(200, 500),
  levelComplete: () => {
    playTone(523, 100);
    setTimeout(() => playTone(659, 100), 100);
    setTimeout(() => playTone(784, 200), 200);
  },
  gameOver: () => {
    playTone(392, 200);
    setTimeout(() => playTone(330, 200), 200);
    setTimeout(() => playTone(262, 400), 400);
  }
};

function playTone(frequency, duration) {
  if (!gameState.soundEnabled) return;
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = frequency;
    oscillator.type = 'square';

    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration / 1000);
  } catch (e) {}
}

function playSound(soundName) {
  if (sounds[soundName]) sounds[soundName]();
}

function generateLevelSelect() {
  const levelGrid = document.getElementById('levelGrid');
  levelGrid.innerHTML = '';

  for (let i = 1; i <= 20; i++) {
    const btn = document.createElement('button');
    btn.className = 'level-btn bg-black/40 text-white hover:bg-primary hover:text-background-dark';
    btn.textContent = i;

    if (i > gameState.maxLevelReached) {
      btn.classList.add('locked');
      btn.disabled = true;
      btn.innerHTML = `<span class="material-symbols-outlined">lock</span>`;
    } else {
      btn.addEventListener('click', () => {
        document.getElementById('levelSelectModal').classList.remove('active');
        document.getElementById('startModal').classList.remove('active');
        initGame(i);
      });
    }

    levelGrid.appendChild(btn);
  }
}

function initGame(startLevel = 1) {
  gameState.score = 0;
  gameState.lives = 5;
  gameState.level = startLevel;
  gameState.isPaused = false;
  gameState.isGameOver = false;
  gameState.playerPos = { ...CONFIG.PLAYER_START };  // ‚úÖ FIXED
  gameState.collectedDots = 0;
  gameState.totalDots = 0;
  gameState.totalTime = 0;
  gameState.combo = 0;

  gameState.ghosts.forEach(ghost => ghost.destroy());
  gameState.ghosts = [];

  gameState.highScore = parseInt(localStorage.getItem('mazeHighScore')) || 0;
  gameState.maxLevelReached = parseInt(localStorage.getItem('maxLevelReached')) || 1;

  loadLevel(startLevel);
  updateUI();
  startGameTimer();
}

function loadLevel(levelNum) {
  gameState.level = levelNum;
  gameState.collectedDots = 0;
  gameState.totalDots = 0;
  gameState.powerUpActive = false;
  gameState.bonusActive = false;
  gameState.combo = 0;
  gameState.gameTimer = 0;

  if (gameState.powerUpTimer) clearTimeout(gameState.powerUpTimer);
  if (gameState.bonusTimer) clearTimeout(gameState.bonusTimer);
  if (gameState.bonusSpawnTimer) clearTimeout(gameState.bonusSpawnTimer);
  if (gameState.comboTimer) clearTimeout(gameState.comboTimer);

  gameState.ghosts.forEach(ghost => ghost.destroy());
  gameState.ghosts = [];

  const mazeGrid = document.getElementById('mazeGrid');
  mazeGrid.innerHTML = '';

  const maze = MAZE_LEVELS[levelNum - 1];
  let playerSpawn = {row:1, col:1};

  maze.forEach((row, rowIndex) => {
    row.forEach((cell, colIndex) => {
      const cellDiv = document.createElement('div');
      cellDiv.dataset.row = rowIndex;
      cellDiv.dataset.col = colIndex;

      if (cell === 1) {
        cellDiv.className = 'maze-wall';
      } else {
        cellDiv.className = 'maze-path';
        if (cell === 0) {
          cellDiv.classList.add('maze-dot');
          gameState.totalDots++;
        } else if (cell === 3) {
          cellDiv.classList.add('maze-path', 'maze-dot', 'maze-powerup');
          gameState.totalDots++;
        } else if (cell === 2) {
          playerSpawn = { row: rowIndex, col: colIndex };
        }
      }
      mazeGrid.appendChild(cellDiv);
    });
  });

  // ‚úÖ FIXED: Player starts at custom spawn or default corner
  if (playerSpawn) {
    gameState.playerPos = { ...CONFIG.PLAYER_START };
  } else {
    gameState.playerPos = { ...CONFIG.PLAYER_START };
  }

  // ‚úÖ FIXED: Ghosts spawn at CENTER, away from player
  const numGhosts = Math.min(4, 1 + Math.floor((levelNum - 1) / 5));
  const ghostConfigs = [
    { color: '#FF0000', behavior: 'chase' },
    { color: '#FFB8FF', behavior: 'ambush' },
    { color: '#00FFFF', behavior: 'random' },
    { color: '#FFB852', behavior: 'shy' }
  ];

  for (let i = 0; i < numGhosts; i++) {
    const config = ghostConfigs[i];
    // ‚úÖ SPREAD GHOSTS AROUND CENTER
    const ghostPos = {
      row: CONFIG.GHOST_START.row,
      col: CONFIG.GHOST_START.col + i
    };
    const ghost = new Ghost(i, config.color, ghostPos, config.behavior);
    gameState.ghosts.push(ghost);
  }

  updatePlayerPosition();
  updateUI();

  gameState.bonusSpawnTimer = setTimeout(spawnBonus, CONFIG.BONUS_SPAWN_TIME);
}

function spawnBonus() {
  if (gameState.isGameOver || gameState.isPaused) return;

  const cells = document.querySelectorAll('.maze-path:not(.maze-dot):not(.maze-bonus)');
  if (cells.length > 0) {
    const cell = cells[Math.floor(Math.random() * cells.length)];
    cell.classList.add('maze-bonus');
    gameState.bonusActive = true;

    gameState.bonusTimer = setTimeout(() => {
      cell.classList.remove('maze-bonus');
      gameState.bonusActive = false;
    }, CONFIG.BONUS_DURATION);
  }
}

function updatePlayerPosition() {
  const player = document.getElementById('player');
  player.style.top = (gameState.playerPos.row * CONFIG.CELL_SIZE) + '%';
  player.style.left = (gameState.playerPos.col * CONFIG.CELL_SIZE) + '%';

  const rotations = { right: 0, down: 90, left: 180, up: 270 };
  player.style.transform = `rotate(${rotations[gameState.direction]}deg)`;
}

function isValidPosition(row, col) {
  if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) return false;
  return MAZE_LEVELS[gameState.level - 1][row][col] !== 1;
}

function collectDot(row, col) {
  const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
  if (!cell) return;

  if (cell.classList.contains('maze-dot') && !cell.classList.contains('collected')) {
    cell.classList.add('collected');
    gameState.collectedDots++;

    if (cell.classList.contains('maze-powerup')) {
      activatePowerUp();
      addScore(CONFIG.POINTS.POWER_UP);
      playSound('powerUp');
    } else {
      addScore(CONFIG.POINTS.DOT);
      playSound('dot');
    }

    incrementCombo();
    updateProgress();
    createParticles(cell);

    if (gameState.collectedDots >= gameState.totalDots) {
      levelComplete();
    }
  }

  if (cell.classList.contains('maze-bonus') && !cell.classList.contains('collected')) {
    cell.classList.add('collected');
    cell.classList.remove('maze-bonus');
    addScore(CONFIG.POINTS.BONUS);
    playSound('bonus');
    gameState.bonusActive = false;
    createParticles(cell);
  }
}

function addScore(points) {
  const multiplier = Math.floor(gameState.combo / 5) + 1;
  const finalPoints = points * multiplier;
  gameState.score += finalPoints;

  if (multiplier > 1) {
    showComboText(`x${multiplier}`, finalPoints);
  }

  if (gameState.score > gameState.highScore) {
    gameState.highScore = gameState.score;
    localStorage.setItem('mazeHighScore', gameState.highScore);
  }

  updateUI();
}

function incrementCombo() {
  gameState.combo++;

  if (gameState.comboTimer) clearTimeout(gameState.comboTimer);
  gameState.comboTimer = setTimeout(() => {
    gameState.combo = 0;
    updateUI();
  }, CONFIG.COMBO_TIMEOUT);

  updateUI();
}

function activatePowerUp() {
  gameState.powerUpActive = true;
  gameState.ghosts.forEach(ghost => ghost.setFrightened(true));

  if (gameState.powerUpTimer) clearTimeout(gameState.powerUpTimer);
  gameState.powerUpTimer = setTimeout(() => {
    gameState.powerUpActive = false;
    gameState.ghosts.forEach(ghost => ghost.setFrightened(false));
  }, CONFIG.POWER_UP_DURATION);
}

function movePlayer(direction) {
  if (gameState.isPaused || gameState.isGameOver) return;

  const newPos = { ...gameState.playerPos };
  gameState.direction = direction;

  switch (direction) {
    case 'up': newPos.row--; break;
    case 'down': newPos.row++; break;
    case 'left': newPos.col--; break;
    case 'right': newPos.col++; break;
  }

  if (isValidPosition(newPos.row, newPos.col)) {
    gameState.playerPos = newPos;
    updatePlayerPosition();
    collectDot(newPos.row, newPos.col);

    const player = document.getElementById('player');
    player.classList.add('moving');
    setTimeout(() => player.classList.remove('moving'), 120);
  }
}

function loseLife() {
  if (gameState.powerUpActive) return;

  gameState.lives--;
  playSound('loseLife');
  shakeScreen();
  updateUI();

  if (gameState.lives <= 0) {
    gameOver();
  } else {
    // ‚úÖ FIXED: Reset to spawn position
    gameState.playerPos = { ...CONFIG.PLAYER_START };
    updatePlayerPosition();
    gameState.ghosts.forEach(ghost => ghost.respawn());
  }
}

function levelComplete() {
  gameState.isPaused = true;
  playSound('levelComplete');

  if (gameState.level > gameState.maxLevelReached) {
    gameState.maxLevelReached = gameState.level;
    localStorage.setItem('maxLevelReached', gameState.maxLevelReached);
  }

  const timeScore = Math.max(0, 100 - gameState.gameTimer);
  const stars = timeScore > 70 ? 3 : timeScore > 40 ? 2 : 1;
  const timeBonus = Math.floor(timeScore * 10);
  gameState.score += timeBonus;
  gameState.totalTime += gameState.gameTimer;

  document.getElementById('levelScore').textContent = gameState.score;
  document.getElementById('levelTime').textContent = gameState.gameTimer;
  document.getElementById('timeBonus').textContent = timeBonus;

  const starsContainer = document.getElementById('starsContainer');
  starsContainer.innerHTML = '';
  for (let i = 0; i < stars; i++) {
    const star = document.createElement('span');
    star.className = 'star';
    star.textContent = '‚≠ê';
    star.style.animationDelay = `${i * 0.2}s`;
    starsContainer.appendChild(star);
  }

  document.getElementById('levelCompleteModal').classList.add('active');

  if (gameState.score > gameState.highScore) {
    gameState.highScore = gameState.score;
    localStorage.setItem('mazeHighScore', gameState.highScore);
  }
}

function nextLevel() {
  document.getElementById('levelCompleteModal').classList.remove('active');

  if (gameState.level >= 20) {
    victory();
  } else {
    gameState.level++;
    loadLevel(gameState.level);
    gameState.isPaused = false;
  }
}

function victory() {
  gameState.isGameOver = true;

  document.getElementById('victoryScore').textContent = gameState.score;
  document.getElementById('totalTime').textContent = gameState.totalTime;
  document.getElementById('victoryModal').classList.add('active');

  if (gameState.score > gameState.highScore) {
    gameState.highScore = gameState.score;
    localStorage.setItem('mazeHighScore', gameState.highScore);
  }

  stopGameTimer();
}

function gameOver() {
  gameState.isGameOver = true;
  gameState.isPaused = true;
  playSound('gameOver');

  document.getElementById('finalLevel').textContent = gameState.level;
  document.getElementById('finalScore').textContent = gameState.score;
  document.getElementById('gameOverHighScore').textContent = gameState.highScore;
  document.getElementById('gameOverModal').classList.add('active');

  stopGameTimer();
}

function updateUI() {
  document.getElementById('score').textContent = gameState.score;
  document.getElementById('highScore').textContent = gameState.highScore;
  document.getElementById('levelDisplay').textContent = gameState.level;
  document.getElementById('timer').textContent = gameState.gameTimer;

  const livesContainer = document.getElementById('lives');
  livesContainer.innerHTML = '';
  for (let i = 0; i < 5; i++) {
    const heart = document.createElement('span');
    heart.className = 'material-symbols-outlined text-2xl';
    heart.textContent = 'favorite';
    heart.classList.add(i < gameState.lives ? 'text-primary' : 'text-primary/30');
    livesContainer.appendChild(heart);
  }

  const comboEl = document.getElementById('combo');
  if (gameState.combo >= 5) {
    const multiplier = Math.floor(gameState.combo / 5) + 1;
    comboEl.textContent = `x${multiplier}`;
    comboEl.style.display = 'inline';
  } else {
    comboEl.style.display = 'none';
  }
}

function updateProgress() {
  const progress = (gameState.collectedDots / gameState.totalDots) * 100;
  document.getElementById('progressFill').style.width = progress + '%';
}

function showComboText(text, points) {
  const container = document.getElementById('gameContainer');
  const comboDiv = document.createElement('div');
  comboDiv.className = 'combo-display';
  comboDiv.textContent = `${text} +${points}`;
  container.appendChild(comboDiv);

  setTimeout(() => comboDiv.remove(), 1000);
}

function createParticles(cell) {
  const rect = cell.getBoundingClientRect();
  const container = document.getElementById('gameContainer');

  for (let i = 0; i < 6; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    const angle = (Math.PI * 2 * i) / 6;
    const distance = 20;
    particle.style.cssText = `
      left: ${rect.left - container.getBoundingClientRect().left + rect.width / 2}px;
      top: ${rect.top - container.getBoundingClientRect().top + rect.height / 2}px;
      --x: ${Math.cos(angle) * distance}px;
      --y: ${Math.sin(angle) * distance}px;
    `;
    container.appendChild(particle);
    setTimeout(() => particle.remove(), 500);
  }
}

function shakeScreen() {
  document.getElementById('gameContainer').classList.add('shake');
  setTimeout(() => {
    document.getElementById('gameContainer').classList.remove('shake');
  }, 300);
}

function startGameTimer() {
  if (gameState.gameTimerInterval) clearInterval(gameState.gameTimerInterval);
  gameState.gameTimerInterval = setInterval(() => {
    if (!gameState.isPaused && !gameState.isGameOver) {
      gameState.gameTimer++;
      updateUI();
    }
  }, 1000);
}

function stopGameTimer() {
  if (gameState.gameTimerInterval) {
    clearInterval(gameState.gameTimerInterval);
    gameState.gameTimerInterval = null;
  }
}

function togglePause() {
  if (gameState.isGameOver) return;

  gameState.isPaused = !gameState.isPaused;
  const pauseModal = document.getElementById('pauseModal');
  const pauseBtn = document.getElementById('pauseBtn').querySelector('span');

  if (gameState.isPaused) {
    document.getElementById('pauseLevel').textContent = gameState.level;
    document.getElementById('pauseScore').textContent = gameState.score;
    pauseModal.classList.add('active');
    pauseBtn.textContent = 'play_arrow';
  } else {
    pauseModal.classList.remove('active');
    pauseBtn.textContent = 'pause';
  }
}

document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('startModal').classList.remove('active');
  initGame(1);
});

document.getElementById('levelSelectBtn').addEventListener('click', () => {
  generateLevelSelect();
  document.getElementById('levelSelectModal').classList.add('active');
});

document.getElementById('closeLevelSelectBtn').addEventListener('click', () => {
  document.getElementById('levelSelectModal').classList.remove('active');
});

document.getElementById('tutorialBtn').addEventListener('click', () => {
  document.getElementById('tutorialModal').classList.add('active');
});

document.getElementById('closeTutorialBtn').addEventListener('click', () => {
  document.getElementById('tutorialModal').classList.remove('active');
});

document.getElementById('upBtn').addEventListener('click', () => movePlayer('up'));
document.getElementById('downBtn').addEventListener('click', () => movePlayer('down'));
document.getElementById('leftBtn').addEventListener('click', () => movePlayer('left'));
document.getElementById('rightBtn').addEventListener('click', () => movePlayer('right'));

document.getElementById('pauseBtn').addEventListener('click', togglePause);
document.getElementById('resumeBtn').addEventListener('click', togglePause);
document.getElementById('quitBtn').addEventListener('click', () => {
  document.getElementById('pauseModal').classList.remove('active');
  gameOver();
});

document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
document.getElementById('restartBtn').addEventListener('click', () => {
  document.getElementById('gameOverModal').classList.remove('active');
  initGame(1);
});

document.getElementById('menuBtn').addEventListener('click', () => {
  document.getElementById('gameOverModal').classList.remove('active');
  document.getElementById('startModal').classList.add('active');
});

document.getElementById('playAgainBtn').addEventListener('click', () => {
  document.getElementById('victoryModal').classList.remove('active');
  initGame(1);
});

document.getElementById('soundBtn').addEventListener('click', () => {
  gameState.soundEnabled = !gameState.soundEnabled;
  const icon = document.getElementById('soundBtn').querySelector('span');
  icon.textContent = gameState.soundEnabled ? 'volume_up' : 'volume_off';
});

document.addEventListener('keydown', (e) => {
  if (document.getElementById('startModal').classList.contains('active')) return;

  switch(e.key) {
    case 'ArrowUp':
    case 'w':
    case 'W':
      e.preventDefault();
      movePlayer('up');
      break;
    case 'ArrowDown':
    case 's':
    case 'S':
      e.preventDefault();
      movePlayer('down');
      break;
    case 'ArrowLeft':
    case 'a':
    case 'A':
      e.preventDefault();
      movePlayer('left');
      break;
    case 'ArrowRight':
    case 'd':
    case 'D':
      e.preventDefault();
      movePlayer('right');
      break;
    case ' ':
    case 'Escape':
      e.preventDefault();
      togglePause();
      break;
  }
});

let touchStartX = 0;
let touchStartY = 0;

document.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});

document.addEventListener('touchend', (e) => {
  if (gameState.isPaused || gameState.isGameOver) return;

  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;

  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;

  const minSwipeDistance = 30;

  if (Math.abs(deltaX) > Math.abs(deltaY)) {
    if (Math.abs(deltaX) > minSwipeDistance) {
      movePlayer(deltaX > 0 ? 'right' : 'left');
    }
  } else {
    if (Math.abs(deltaY) > minSwipeDistance) {
      movePlayer(deltaY > 0 ? 'down' : 'up');
    }
  }
});

document.addEventListener('DOMContentLoaded', () => {
  const highScore = localStorage.getItem('mazeHighScore') || 0;
  document.getElementById('highScore').textContent = highScore;
  generateLevelSelect();
});
</script>
</body>
</html>