<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Candy Crush — Polished</title>
  <style>
    :root{
      --bg:#1a0f22;
      --panel: rgba(255,255,255,0.06);
      --glass: rgba(255,255,255,0.08);
      --accent: #ffd54a;
      --board-size: 8;
      --gap: 6px;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: radial-gradient(circle at 10% 10%, rgba(255,255,255,0.03), transparent 10%),
                  linear-gradient(180deg,#0f0712 0%, #1a0f22 100%);
      color:#fff;display:flex;align-items:center;justify-content:center;padding:20px;min-height:100vh;
    }

    .wrapper{width:100%;max-width:520px}

    .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;gap:12px}
    .panel{background:var(--panel);border-radius:18px;padding:12px 18px;display:flex;gap:12px;align-items:center;box-shadow:0 6px 30px rgba(0,0,0,0.45);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,0.04)}
    .label{font-size:12px;color:rgba(255,255,255,0.75)}
    .value{font-size:20px;font-weight:700;color:var(--accent)}

    .board{display:grid;grid-template-columns: repeat(var(--board-size), 1fr);gap:var(--gap);background:var(--glass);padding:10px;border-radius:18px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 40px rgba(0,0,0,0.4);aspect-ratio:1;position:relative}
    .cell{position:relative;aspect-ratio:1;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));display:flex;align-items:center;justify-content:center;cursor:pointer;transition:transform .12s ease}
    .cell:active{transform:scale(.98)}

    /* candy base */
    .candy{width:78%;height:78%;display:flex;align-items:center;justify-content:center;position:absolute;z-index:5;transition:transform .28s cubic-bezier(.2,.9,.2,1),opacity .25s;pointer-events:none}
    .candy svg{width:100%;height:100%;display:block}

    /* glowing aura */
    .candy .glow{filter: blur(8px);opacity:.6}

    /* selection */
    .cell.selected{box-shadow:0 0 22px rgba(255,213,74,0.16);border-radius:14px}

    /* shapes have small rotation offsets to add life */
    .shape-0{transform-origin:center;}
    .shape-1{transform-origin:center;}
    .shape-2{transform-origin:center;}

    /* drop-in animation for new candies */
    @keyframes dropIn{0%{transform:translateY(-20%) scale(.9);opacity:0}60%{transform:translateY(6%) scale(1.03);opacity:1}100%{transform:translateY(0) scale(1)}}
    .drop{animation:dropIn .42s cubic-bezier(.2,.85,.25,1)}

    /* pop animation when matched */
    @keyframes popOut{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(.02);opacity:0}}
    .pop{animation:popOut .42s ease forwards}

    /* score popup */
    .score-popup{position:absolute;font-weight:800;font-size:18px;color:var(--accent);pointer-events:none;transform:translate(-50%,-50%);opacity:0;animation:scoreFloat 1s forwards}
    @keyframes scoreFloat{0%{transform:translate(-50%,-20px);opacity:1}100%{transform:translate(-50%,-80px);opacity:0}}

    /* particle burst */
    .particle{position:absolute;width:8px;height:8px;border-radius:50%;opacity:0;transform:translate(-50%,-50%);animation:burst 700ms ease-out forwards}
    @keyframes burst{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-60px) scale(.2)}}

    .controls{display:flex;gap:12px;justify-content:center;margin-top:14px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:10px 16px;border-radius:40px;cursor:pointer;color:var(--accent);font-weight:700}

    .footer{margin-top:14px;text-align:center;color:rgba(255,255,255,0.7);font-size:13px}

    /* responsive */
    @media (max-width:480px){:root{--gap:4px}}
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="header">
      <div class="panel">
        <div style="margin-right:8px">
          <div class="label">SCORE</div>
          <div class="value" id="score">0</div>
        </div>
        <div style="margin-left:auto">
          <div class="label">MOVES</div>
          <div class="value" id="moves">30</div>
        </div>
      </div>
    </div>

    <div id="board" class="board" role="application" aria-label="Candy board"></div>

    <div class="controls">
      <button id="reset-btn" class="btn">New Game</button>
      <button id="hint-btn" class="btn">Hint</button>
    </div>

    <div class="footer">Tap or swipe a candy — match 3+ to score. Shapes & icons add more visual variety!</div>
  </div>

  <script>
    // --- CONFIG ---
    const COLORS = ['red','blue','green','yellow','purple','orange'];
    const BOARD_SIZE = 8;
    const INITIAL_MOVES = 30;

    // map each color to an icon (inline SVG). Different shapes per color create visual variety.
    const SVG_MAP = {
      red: `<svg viewBox="0 0 64 64" aria-hidden><defs><linearGradient id="g-red" x1="0" x2="1"><stop offset="0" stop-color="#ff6b81"/><stop offset="1" stop-color="#ff3b3b"/></linearGradient></defs><g><path fill="url(#g-red)" d="M32 52s20-12 20-27S42 2 32 14 12 11 12 25 32 52 32 52z"/></g></svg>`,
      blue:`<svg viewBox="0 0 64 64" aria-hidden><defs><linearGradient id="g-blue" x1="0" x2="1"><stop offset="0" stop-color="#6fb3ff"/><stop offset="1" stop-color="#1e6fff"/></linearGradient></defs><g><path fill="url(#g-blue)" d="M32 8l12 22-12 6-12-6 12-22z"/></g></svg>`,
      green:`<svg viewBox="0 0 64 64" aria-hidden><defs><linearGradient id="g-green" x1="0" x2="1"><stop offset="0" stop-color="#7ef0b6"/><stop offset="1" stop-color="#12c48b"/></linearGradient></defs><g><path fill="url(#g-green)" d="M32 8c10 0 16 8 16 18s-8 16-16 28C16 42 8 34 8 26S22 8 32 8z"/></g></svg>`,
      yellow:`<svg viewBox="0 0 64 64" aria-hidden><defs><linearGradient id="g-yellow" x1="0" x2="1"><stop offset="0" stop-color="#fff08a"/><stop offset="1" stop-color="#ffcf34"/></linearGradient></defs><g><path fill="url(#g-yellow)" d="M32 6l6 14 14 2-10 10 2 14-12-8-12 8 2-14-10-10 14-2 6-14z"/></g></svg>`,
      purple:`<svg viewBox="0 0 64 64" aria-hidden><defs><linearGradient id="g-purple" x1="0" x2="1"><stop offset="0" stop-color="#c29bff"/><stop offset="1" stop-color="#7a4bff"/></linearGradient></defs><g><path fill="url(#g-purple)" d="M32 10c8 0 14 10 14 18s-6 14-14 22-14-10-14-18 6-22 14-22z"/></g></svg>`,
      orange:`<svg viewBox="0 0 64 64" aria-hidden><defs><linearGradient id="g-orange" x1="0" x2="1"><stop offset="0" stop-color="#ffd2a1"/><stop offset="1" stop-color="#ff7a2b"/></linearGradient></defs><g><path fill="url(#g-orange)" d="M32 8l12 6 6 12-6 12-12 6-12-6-6-12 6-12 12-6z"/></g></svg>`
    };

    // game state
    let board = [];
    let score = 0;
    let moves = INITIAL_MOVES;
    let selected = null;
    let isAnimating = false;
    let gameActive = true;

    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const movesEl = document.getElementById('moves');
    const resetBtn = document.getElementById('reset-btn');
    const hintBtn = document.getElementById('hint-btn');

    // --- helpers ---
    function randomColor(){return COLORS[Math.floor(Math.random()*COLORS.length)]}

    function createBoard(){
      const b=[];
      for(let r=0;r<BOARD_SIZE;r++){
        b[r]=[];
        for(let c=0;c<BOARD_SIZE;c++){
          let col; do{col=randomColor()}while((c>=2 && b[r][c-1]===col && b[r][c-2]===col)||(r>=2&&b[r-1][c]===col&&b[r-2][c]===col));
          b[r][c]=col;
        }
      }
      return b;
    }

    // build candy element with SVG icon
    function makeCandy(color){
      const el = document.createElement('div');
      el.className = 'candy drop';
      el.dataset.color = color;
      el.innerHTML = SVG_MAP[color] || SVG_MAP[COLORS[0]];
      // small random rotation for variety
      el.style.transform = `rotate(${(Math.random()*10-5).toFixed(2)}deg)`;
      return el;
    }

    function renderBoard(){
      boardEl.innerHTML='';
      for(let r=0;r<BOARD_SIZE;r++){
        for(let c=0;c<BOARD_SIZE;c++){
          const cell=document.createElement('div');
          cell.className='cell';
          cell.dataset.row=r;cell.dataset.col=c;

          if(board[r][c]){
            const candy = makeCandy(board[r][c]);
            cell.appendChild(candy);
          }

          // pointer events
          cell.addEventListener('pointerdown', e=>onPointerDown(e,r,c));
          cell.addEventListener('click', ()=>onCellClick(r,c));
          boardEl.appendChild(cell);
        }
      }
    }

    // single-cell rendering used after swaps
    function renderCell(r,c){
      const cell=document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      if(!cell) return;
      cell.innerHTML='';
      if(board[r][c]) cell.appendChild(makeCandy(board[r][c]));
    }

    // --- input handling (tap & drag) ---
    let dragStart=null;
    function onPointerDown(e,r,c){
      if(!gameActive||isAnimating) return;
      dragStart={x:e.clientX,y:e.clientY,r,c};
      const onUp = ev=>{
        const dx=ev.clientX-dragStart.x; const dy=ev.clientY-dragStart.y;
        const absX=Math.abs(dx), absY=Math.abs(dy);
        const threshold=20;
        let tr=r,tc=c;
        if(Math.max(absX,absY)>threshold){
          if(absX>absY) tc = dx>0? c+1: c-1; else tr = dy>0? r+1: r-1;
          attemptSwap(r,c,tr,tc);
        } else {
          // treat as tap
          onCellClick(r,c);
        }
        window.removeEventListener('pointerup', onUp);
      };
      window.addEventListener('pointerup', onUp);
    }

    function onCellClick(r,c){
      if(!gameActive||isAnimating) return;
      const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      if(!selected){ selected={r,c}; cell.classList.add('selected'); }
      else{
        const prevCell = document.querySelector(`.cell[data-row="${selected.r}"][data-col="${selected.c}"]`);
        prevCell?.classList.remove('selected');
        // if same cell => deselect
        if(selected.r===r && selected.c===c){ selected=null; return; }
        const adjacent = (Math.abs(selected.r-r)+Math.abs(selected.c-c))===1;
        if(adjacent) attemptSwap(selected.r,selected.c,r,c);
        else { selected={r,c}; cell.classList.add('selected'); }
      }
    }

    // attempt swap and handle moves
    function attemptSwap(r1,c1,r2,c2){
      if(r2<0||r2>=BOARD_SIZE||c2<0||c2>=BOARD_SIZE) return;
      moves--; updateUI();
      if(moves<=0){ setTimeout(()=>{ if(moves<=0) endGame(); },600); }
      performSwap(r1,c1,r2,c2);
    }

    function performSwap(r1,c1,r2,c2){
      isAnimating=true;
      const cellA = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
      const cellB = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
      if(!cellA||!cellB){ isAnimating=false; return; }
      const a = cellA.querySelector('.candy');
      const b = cellB.querySelector('.candy');
      if(a) a.style.transition='transform .28s cubic-bezier(.2,.9,.2,1)';
      if(b) b.style.transition='transform .28s cubic-bezier(.2,.9,.2,1)';

      const rectA = cellA.getBoundingClientRect();
      const rectB = cellB.getBoundingClientRect();
      const dx = rectB.left - rectA.left; const dy = rectB.top - rectA.top;

      if(a) a.style.transform = `translate(${dx}px,${dy}px)`;
      if(b) b.style.transform = `translate(${-dx}px,${-dy}px)`;

      setTimeout(()=>{
        // swap data
        [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
        renderCell(r1,c1); renderCell(r2,c2);

        const matches = findMatches();
        if(matches.length>0) removeMatches(matches);
        else{
          // swap back
          const cellA2 = document.querySelector(`.cell[data-row="${r1}"][data-col="${c1}"]`);
          const cellB2 = document.querySelector(`.cell[data-row="${r2}"][data-col="${c2}"]`);
          const a2 = cellA2?.querySelector('.candy');
          const b2 = cellB2?.querySelector('.candy');
          if(a2) a2.style.transition='transform .28s cubic-bezier(.2,.9,.2,1)';
          if(b2) b2.style.transition='transform .28s cubic-bezier(.2,.9,.2,1)';
          if(a2) a2.style.transform = `translate(${dx}px,${dy}px)`;
          if(b2) b2.style.transform = `translate(${-dx}px,${-dy}px)`;
          // force reflow then clear
          void (a2 && a2.offsetWidth);
          setTimeout(()=>{
            [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
            renderCell(r1,c1); renderCell(r2,c2);
            isAnimating=false;
            if(moves<=0 && findMatches().length===0) endGame();
          },300);
        }
      },300);
    }

    // --- matching logic ---
    function findMatches(){
      const matches=[];
      // horizontal
      for(let r=0;r<BOARD_SIZE;r++){
        let run=1; let color=board[r][0];
        for(let c=1;c<BOARD_SIZE;c++){
          if(board[r][c] && board[r][c]===color) run++; else{
            if(run>=3 && color) for(let k=c-run;k<c;k++) matches.push({r,c:k});
            run=1; color=board[r][c];
          }
        }
        if(run>=3 && color) for(let k=BOARD_SIZE-run;k<BOARD_SIZE;k++) matches.push({r,c:k});
      }
      // vertical
      for(let c=0;c<BOARD_SIZE;c++){
        let run=1; let color=board[0][c];
        for(let r=1;r<BOARD_SIZE;r++){
          if(board[r][c] && board[r][c]===color) run++; else{
            if(run>=3 && color) for(let k=r-run;k<r;k++) matches.push({r:k,c});
            run=1; color=board[r][c];
          }
        }
        if(run>=3 && color) for(let k=BOARD_SIZE-run;k<BOARD_SIZE;k++) matches.push({r:k,c});
      }
      // unique
      const set=new Set(); const uniq=[];
      for(const m of matches){const key=`${m.r},${m.c}`; if(!set.has(key)){set.add(key);uniq.push(m)}}
      return uniq;
    }

    // remove matches, score, drop, refill
    function removeMatches(matches){
      // scoring
      let pts = matches.length * 10;
      if(matches.length>=5) pts += 50; else if(matches.length===4) pts += 20;
      score += pts; updateUI();

      // show score popup at center
      const center = getCenter(matches);
      showScorePopup(pts, center);

      // animate pop & particles
      matches.forEach(({r,c})=>{
        const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
        const candy = cell?.querySelector('.candy');
        if(candy){ candy.classList.add('pop'); }
        spawnParticles(cell);
      });

      setTimeout(()=>{
        // clear
        for(const {r,c} of matches) board[r][c]=null;
        // drop
        for(let c=0;c<BOARD_SIZE;c++){
          let write=BOARD_SIZE-1;
          for(let r=BOARD_SIZE-1;r>=0;r--){ if(board[r][c]!==null){ board[write][c]=board[r][c]; if(write!==r) board[r][c]=null; write--; }}
          for(let r=write;r>=0;r--) board[r][c]=randomColor();
        }
        renderBoard();
        setTimeout(()=>{
          const newMatches = findMatches();
          if(newMatches.length>0) removeMatches(newMatches); else{ isAnimating=false; if(moves<=0) endGame(); }
        },360);
      },420);
    }

    function getCenter(matches){
      let tr=0,tc=0; for(const m of matches){tr+=m.r;tc+=m.c} return {r:Math.round(tr/matches.length),c:Math.round(tc/matches.length)};
    }

    function showScorePopup(pts, center){
      const popup = document.createElement('div'); popup.className='score-popup'; popup.textContent=`+${pts}`;
      const cell = document.querySelector(`.cell[data-row="${center.r}"][data-col="${center.c}"]`);
      if(cell){
        const rect = cell.getBoundingClientRect(); const parentRect = boardEl.getBoundingClientRect();
        popup.style.left = `${(rect.left - parentRect.left) + rect.width/2}px`;
        popup.style.top = `${(rect.top - parentRect.top) + rect.height/2}px`;
        boardEl.appendChild(popup);
        setTimeout(()=>popup.remove(),1000);
      }
    }

    // particle burst
    function spawnParticles(cell){
      if(!cell) return;
      const rect = cell.getBoundingClientRect(); const parentRect = boardEl.getBoundingClientRect();
      for(let i=0;i<6;i++){
        const p = document.createElement('div'); p.className='particle';
        p.style.left = `${(rect.left - parentRect.left) + Math.random()*rect.width}px`;
        p.style.top = `${(rect.top - parentRect.top) + Math.random()*rect.height}px`;
        p.style.background = ['#ffd54a','#ff6b81','#7ef0b6','#6fb3ff','#c29bff'][Math.floor(Math.random()*5)];
        boardEl.appendChild(p);
        setTimeout(()=>p.remove(),800);
      }
    }

    // UI updates
    function updateUI(){ scoreEl.textContent = score; movesEl.textContent = moves }

    function endGame(){ gameActive=false; alert(`Game Over! Final score: ${score}`); }

    // hint (simple find first match by trying swaps)
    function findHint(){
      for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dr,dc] of dirs){
          const rr=r+dr, cc=c+dc; if(rr<0||cc<0||rr>=BOARD_SIZE||cc>=BOARD_SIZE) continue;
          [board[r][c],board[rr][cc]]=[board[rr][cc],board[r][c]];
          const matches = findMatches();
          [board[r][c],board[rr][cc]]=[board[rr][cc],board[r][c]];
          if(matches.length>0) return [{r,c},{r:rr,c:cc}];
        }
      }
      return null;
    }

    hintBtn.addEventListener('click', ()=>{
      const hint = findHint();
      if(!hint) { alert('No moves found!'); return }
      const a = document.querySelector(`.cell[data-row="${hint[0].r}"][data-col="${hint[0].c}"]`);
      const b = document.querySelector(`.cell[data-row="${hint[1].r}"][data-col="${hint[1].c}"]`);
      a?.classList.add('selected'); setTimeout(()=>a?.classList.remove('selected'),800);
      b?.classList.add('selected'); setTimeout(()=>b?.classList.remove('selected'),800);
    });

    // reset
    resetBtn.addEventListener('click', initGame);

    // initialize
    function initGame(){ board=createBoard(); score=0; moves=INITIAL_MOVES; selected=null; isAnimating=false; gameActive=true; renderBoard(); updateUI(); }

    initGame();

  </script>
</body>
</html>
