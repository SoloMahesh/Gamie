<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Puzzle</title>
    <style>
        body { margin: 0; background: #faf8ef; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; overflow: hidden; }
        .header { display: flex; justify-content: space-between; width: 90%; max-width: 500px; margin-bottom: 20px; }
        h1 { font-size: 60px; color: #776e65; margin: 0; }
        .scores { display: flex; gap: 10px; }
        .score-box { background: #bbada0; padding: 5px 15px; border-radius: 5px; color: white; text-align: center; }
        .score-label { font-size: 14px; color: #eee4da; }
        .score-val { font-size: 24px; font-weight: bold; }

        .game-container { position: relative; width: 320px; height: 320px; background: #bbada0; border-radius: 10px; padding: 10px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; touch-action: none; }
        .cell { background: #cdc1b4; border-radius: 5px; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-size: 30px; font-weight: bold; color: #776e65; }

        .tile { position: absolute; width: 67.5px; height: 67.5px; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 30px; font-weight: bold; color: #776e65; transition: all 0.15s ease-in-out; }

        .tile-2 { background: #eee4da; }
        .tile-4 { background: #ede0c8; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile-128 { background: #edcf72; color: #f9f6f2; font-size: 24px; }
        .tile-256 { background: #edcc61; color: #f9f6f2; font-size: 24px; }
        .tile-512 { background: #edc850; color: #f9f6f2; font-size: 24px; }
        .tile-1024 { background: #edc53f; color: #f9f6f2; font-size: 18px; }
        .tile-2048 { background: #edc22e; color: #f9f6f2; font-size: 18px; }

        #gameOver { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(238, 228, 218, 0.73); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; display: none; }

        button { background: #8f7a66; color: white; border: none; padding: 10px 20px; font-size: 18px; border-radius: 5px; cursor: pointer; margin-top: 10px; }

        @media (min-width: 500px) {
            .game-container { width: 450px; height: 450px; }
            .tile { width: 100px; height: 100px; font-size: 40px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>2048</h1>
        <div class="scores">
            <div class="score-box">
                <div class="score-label">SCORE</div>
                <div class="score-val" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">BEST</div>
                <div class="score-val" id="bestScore">0</div>
            </div>
        </div>
    </div>

    <div class="game-container" id="grid">
        <!-- Cells -->
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>

        <!-- Tiles will be added here via JS -->

        <div id="gameOver">
            <h2>Game Over!</h2>
            <button onclick="initGame()">Try Again</button>
        </div>
    </div>

    <button onclick="initGame()">New Game</button>
    <p style="color: #776e65;">Use Arrow Keys or Swipe</p>

    <script>
        const gridContainer = document.getElementById('grid');
        const scoreDisplay = document.getElementById('score');
        const bestDisplay = document.getElementById('bestScore');
        const gameOverScreen = document.getElementById('gameOver');

        let grid = [];
        let score = 0;
        let bestScore = localStorage.getItem('2048-best') || 0;
        bestDisplay.innerText = bestScore;

        function initGame() {
            grid = Array(4).fill().map(() => Array(4).fill(0));
            score = 0;
            scoreDisplay.innerText = score;
            gameOverScreen.style.display = 'none';

            // Remove existing tiles
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(t => t.remove());

            addRandomTile();
            addRandomTile();
            render();
        }

        function addRandomTile() {
            const emptyCells = [];
            for(let r=0; r<4; r++) {
                for(let c=0; c<4; c++) {
                    if(grid[r][c] === 0) emptyCells.push({r, c});
                }
            }
            if(emptyCells.length === 0) return;

            const {r, c} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            grid[r][c] = Math.random() < 0.9 ? 2 : 4;
        }

        function render() {
            // We re-render all tiles for simplicity (improving animations would require ID tracking)
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(t => t.remove());

            const size = gridContainer.clientWidth;
            const gap = 10;
            const tileSize = (size - 5 * gap) / 4;

            for(let r=0; r<4; r++) {
                for(let c=0; c<4; c++) {
                    if(grid[r][c] !== 0) {
                        const tile = document.createElement('div');
                        tile.className = `tile tile-${grid[r][c]}`;
                        tile.innerText = grid[r][c];
                        tile.style.left = `${gap + c * (tileSize + gap)}px`;
                        tile.style.top = `${gap + r * (tileSize + gap)}px`;
                        tile.style.width = `${tileSize}px`;
                        tile.style.height = `${tileSize}px`;
                        gridContainer.appendChild(tile);
                    }
                }
            }
        }

        function move(dir) {
            let moved = false;
            const newGrid = JSON.parse(JSON.stringify(grid));

            // Logic for moving
            // dir: 0=up, 1=right, 2=down, 3=left

            const rotate = (matrix) => matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
            const rotateLeft = (matrix) => matrix[0].map((val, index) => matrix.map(row => row[row.length-1-index]));

            // Standardize to Left move
            let rotated = newGrid;
            for(let i=0; i<dir; i++) rotated = rotateLeft(rotated); // Rotate to align direction to Left?
            // Actually:
            // Up (0): Rotate Left once? No.
            // Let's implement row processing.

            /*
              Up: Rotate Left (so top becomes left) -> Slide Left -> Rotate Right
              Right: Rotate 180 (so right becomes left) -> Slide Left -> Rotate 180
              Down: Rotate Right -> Slide Left -> Rotate Left
              Left: Slide Left
            */
            // Better:
            // 0: Up, 1: Right, 2: Down, 3: Left

            let rotationCount = 0;
            if(dir === 0) rotationCount = 1; // Left -> Top
            if(dir === 1) rotationCount = 2; // Left -> Right? No.

            // Let's stick to simple loops.

            const vectors = {
                0: {x: 0, y: -1}, // Up
                1: {x: 1, y: 0},  // Right
                2: {x: 0, y: 1},  // Down
                3: {x: -1, y: 0}  // Left
            };
            const vector = vectors[dir];

            let traversals = { x: [], y: [] };
            for(let pos=0; pos<4; pos++) {
                traversals.x.push(pos);
                traversals.y.push(pos);
            }

            if(vector.x === 1) traversals.x = traversals.x.reverse();
            if(vector.y === 1) traversals.y = traversals.y.reverse();

            let merged = Array(4).fill().map(() => Array(4).fill(false));

            traversals.x.forEach(c => {
                traversals.y.forEach(r => {
                    if(grid[r][c] === 0) return;

                    let cell = { x: c, y: r };
                    let tile = grid[r][c];

                    let next = { x: cell.x + vector.x, y: cell.y + vector.y };

                    while(next.x >= 0 && next.x < 4 && next.y >= 0 && next.y < 4) {
                        const nextCellVal = grid[next.y][next.x];

                        if(nextCellVal === 0) {
                            // Move into empty
                            grid[next.y][next.x] = tile;
                            grid[cell.y][cell.x] = 0;
                            cell = { x: next.x, y: next.y }; // update current pos
                            next = { x: cell.x + vector.x, y: cell.y + vector.y };
                            moved = true;
                        } else if(nextCellVal === tile && !merged[next.y][next.x]) {
                            // Merge
                            grid[next.y][next.x] *= 2;
                            grid[cell.y][cell.x] = 0;
                            merged[next.y][next.x] = true;
                            score += grid[next.y][next.x];
                            moved = true;
                            break; // Done moving
                        } else {
                            break; // Blocked
                        }
                    }
                });
            });

            if(moved) {
                scoreDisplay.innerText = score;
                if(score > bestScore) {
                    bestScore = score;
                    localStorage.setItem('2048-best', bestScore);
                    bestDisplay.innerText = bestScore;
                }
                addRandomTile();
                render();
                if(checkGameOver()) {
                    gameOverScreen.style.display = 'flex';
                }
            }
        }

        function checkGameOver() {
            for(let r=0; r<4; r++) {
                for(let c=0; c<4; c++) {
                    if(grid[r][c] === 0) return false;
                    if(c < 3 && grid[r][c] === grid[r+1][c]) return false;
                    if(r < 3 && grid[r][c] === grid[r+1][c]) return false;
                }
            }
            return true;
        }

        // Input
        document.addEventListener('keydown', e => {
            if(e.key === 'ArrowUp') move(0);
            else if(e.key === 'ArrowRight') move(1);
            else if(e.key === 'ArrowDown') move(2);
            else if(e.key === 'ArrowLeft') move(3);
        });

        // Swipe
        let touchStart = {x:0, y:0};
        gridContainer.addEventListener('touchstart', e => {
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
            e.preventDefault();
        });

        gridContainer.addEventListener('touchend', e => {
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;

            if(Math.abs(dx) > Math.abs(dy)) {
                if(Math.abs(dx) > 30) move(dx > 0 ? 1 : 3);
            } else {
                if(Math.abs(dy) > 30) move(dy > 0 ? 2 : 0);
            }
        });

        window.addEventListener('resize', render);

        initGame();
    </script>
</body>
</html>
