<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candy Crush Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
            overflow: hidden;
        }
        
        .game-container {
            position: relative;
            margin: 20px auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 25px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .score-container, .moves-container {
            text-align: center;
        }
        
        .label {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .value {
            font-size: 24px;
            font-weight: bold;
            color: #ffeb3b;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .cell:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.25);
        }
        
        .cell.selected {
            background: rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px #ffeb3b;
        }
        
        .candy {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .candy::before {
            content: '';
            position: absolute;
            width: 40%;
            height: 40%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        
        .red { background: linear-gradient(135deg, #ff416c, #ff4b2b); }
        .blue { background: linear-gradient(135deg, #1e3c72, #2a5298); }
        .green { background: linear-gradient(135deg, #11998e, #38ef7d); }
        .yellow { background: linear-gradient(135deg, #f7971e, #ffd200); }
        .purple { background: linear-gradient(135deg, #654ea3, #da98b4); }
        .orange { background: linear-gradient(135deg, #ff9a00, #ff5200); }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            font-size: 24px;
            display: none;
            z-index: 10;
            border: 2px solid #ffeb3b;
        }
        
        .message h2 {
            color: #ffeb3b;
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        .instructions {
            margin-top: 20px;
            text-align: center;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .score-popup {
            position: absolute;
            color: #ffeb3b;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            opacity: 0;
            animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="score-container">
            <div class="label">SCORE</div>
            <div class="value" id="score">0</div>
        </div>
        <div class="moves-container">
            <div class="label">MOVES</div>
            <div class="value" id="moves">30</div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="board" id="board"></div>
        <div class="message" id="message">
            <h2>Game Over!</h2>
            <div>Final Score: <span id="final-score">0</span></div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn" id="reset-btn">New Game</button>
    </div>
    
    <div class="instructions">
        Match 3 or more candies of the same color to score points!<br>
        Click on a candy, then click on an adjacent candy to swap them.
    </div>

    <script>
        const COLORS = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
        const BOARD_SIZE = 8;
        const INITIAL_MOVES = 30;
        
        let board = [];
        let score = 0;
        let moves = INITIAL_MOVES;
        let selectedCandy = null;
        let isAnimating = false;
        let gameActive = true;
        
        const boardElement = document.getElementById('board');
        const scoreElement = document.getElementById('score');
        const movesElement = document.getElementById('moves');
        const messageElement = document.getElementById('message');
        const finalScoreElement = document.getElementById('final-score');
        const resetButton = document.getElementById('reset-btn');
        
        // Initialize the game
        function initGame() {
            board = createBoard();
            score = 0;
            moves = INITIAL_MOVES;
            selectedCandy = null;
            isAnimating = false;
            gameActive = true;
            
            updateUI();
            renderBoard();
            messageElement.style.display = 'none';
        }
        
        // Create initial board
        function createBoard() {
            const board = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    let color;
                    do {
                        color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    } while (
                        (col >= 2 && board[row][col-1] === color && board[row][col-2] === color) ||
                        (row >= 2 && board[row-1][col] === color && board[row-2][col] === color)
                    );
                    board[row][col] = color;
                }
            }
            return board;
        }
        
        // Render the board
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const candy = document.createElement('div');
                    candy.className = `candy ${board[row][col]}`;
                    cell.appendChild(candy);
                    
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }
        }
        
        // Handle cell click
        function handleCellClick(row, col) {
            if (!gameActive || isAnimating) return;
            
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            
            if (!selectedCandy) {
                // First candy selection
                selectedCandy = { row, col };
                cell.classList.add('selected');
            } else {
                // Second candy selection
                const prevCell = document.querySelector(`.cell[data-row="${selectedCandy.row}"][data-col="${selectedCandy.col}"]`);
                prevCell.classList.remove('selected');
                
                if (selectedCandy.row === row && selectedCandy.col === col) {
                    // Deselected the same candy
                    selectedCandy = null;
                    return;
                }
                
                // Check if adjacent
                const isAdjacent = (
                    (Math.abs(selectedCandy.row - row) === 1 && selectedCandy.col === col) ||
                    (Math.abs(selectedCandy.col - col) === 1 && selectedCandy.row === row)
                );
                
                if (isAdjacent) {
                    // Valid move - swap candies
                    moves--;
                    updateUI();
                    
                    if (moves <= 0) {
                        endGame();
                        return;
                    }
                    
                    swapCandies(selectedCandy.row, selectedCandy.col, row, col);
                    selectedCandy = null;
                } else {
                    // Not adjacent - select new candy
                    selectedCandy = { row, col };
                    cell.classList.add('selected');
                }
            }
        }
        
        // Swap two candies
        function swapCandies(row1, col1, row2, col2) {
            isAnimating = true;
            
            // Visual swap
            const candy1 = document.querySelector(`.cell[data-row="${row1}"][data-col="${col1}"] .candy`);
            const candy2 = document.querySelector(`.cell[data-row="${row2}"][data-col="${col2}"] .candy`);
            
            // Swap in data
            [board[row1][col1], board[row2][col2]] = [board[row2][col2], board[row1][col1]];
            
            // Re-render affected cells
            renderCell(row1, col1);
            renderCell(row2, col2);
            
            // Check for matches after a short delay
            setTimeout(() => {
                const matches = findMatches();
                if (matches.length > 0) {
                    removeMatches(matches);
                } else {
                    // No matches - swap back
                    [board[row1][col1], board[row2][col2]] = [board[row2][col2], board[row1][col1]];
                    renderCell(row1, col1);
                    renderCell(row2, col2);
                    isAnimating = false;
                }
            }, 300);
        }
        
        // Render a single cell
        function renderCell(row, col) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            cell.innerHTML = '';
            const candy = document.createElement('div');
            candy.className = `candy ${board[row][col]}`;
            cell.appendChild(candy);
        }
        
        // Find all matches
        function findMatches() {
            const matches = [];
            
            // Check horizontal matches
            for (let row = 0; row < BOARD_SIZE; row++) {
                let count = 1;
                let currentColor = board[row][0];
                
                for (let col = 1; col < BOARD_SIZE; col++) {
                    if (board[row][col] === currentColor) {
                        count++;
                    } else {
                        if (count >= 3) {
                            for (let i = col - count; i < col; i++) {
                                matches.push({ row, col: i });
                            }
                        }
                        count = 1;
                        currentColor = board[row][col];
                    }
                }
                
                if (count >= 3) {
                    for (let i = BOARD_SIZE - count; i < BOARD_SIZE; i++) {
                        matches.push({ row, col: i });
                    }
                }
            }
            
            // Check vertical matches
            for (let col = 0; col < BOARD_SIZE; col++) {
                let count = 1;
                let currentColor = board[0][col];
                
                for (let row = 1; row < BOARD_SIZE; row++) {
                    if (board[row][col] === currentColor) {
                        count++;
                    } else {
                        if (count >= 3) {
                            for (let i = row - count; i < row; i++) {
                                matches.push({ row: i, col });
                            }
                        }
                        count = 1;
                        currentColor = board[row][col];
                    }
                }
                
                if (count >= 3) {
                    for (let i = BOARD_SIZE - count; i < BOARD_SIZE; i++) {
                        matches.push({ row: i, col });
                    }
                }
            }
            
            // Remove duplicates
            const uniqueMatches = [];
            const seen = new Set();
            for (const match of matches) {
                const key = `${match.row},${match.col}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueMatches.push(match);
                }
            }
            
            return uniqueMatches;
        }
        
        // Remove matched candies and drop new ones
        function removeMatches(matches) {
            // Add score: 10 points per candy, bonus for larger combos
            let matchScore = 0;
            if (matches.length >= 3) {
                // Base points
                matchScore = matches.length * 10;
                // Bonus for longer chains
                if (matches.length >= 5) matchScore += 50;
                else if (matches.length >= 4) matchScore += 20;
            }
            
            score += matchScore;
            updateUI();
            
            // Show floating score animation
            if (matchScore > 0) {
                showScorePopup(matchScore, getCenterOfMatches(matches));
            }
            
            // Remove matched candies
            for (const { row, col } of matches) {
                board[row][col] = null;
            }
            
            // Drop candies down
            for (let col = 0; col < BOARD_SIZE; col++) {
                let writeIndex = BOARD_SIZE - 1;
                for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                    if (board[row][col] !== null) {
                        board[writeIndex][col] = board[row][col];
                        if (writeIndex !== row) {
                            board[row][col] = null;
                        }
                        writeIndex--;
                    }
                }
                // Fill top with new candies
                for (let row = writeIndex; row >= 0; row--) {
                    board[row][col] = COLORS[Math.floor(Math.random() * COLORS.length)];
                }
            }
            
            // Re-render board
            renderBoard();
            
            // Check for new matches after dropping
            setTimeout(() => {
                const newMatches = findMatches();
                if (newMatches.length > 0) {
                    setTimeout(() => removeMatches(newMatches), 300);
                } else {
                    isAnimating = false;
                    // Check if game should end
                    if (moves <= 0) {
                        endGame();
                    }
                }
            }, 300);
        }
        
        // Calculate center position of matched candies for score popup
        function getCenterOfMatches(matches) {
            let totalRow = 0, totalCol = 0;
            for (const { row, col } of matches) {
                totalRow += row;
                totalCol += col;
            }
            return {
                row: Math.floor(totalRow / matches.length),
                col: Math.floor(totalCol / matches.length)
            };
        }
        
        // Show floating score popup
        function showScorePopup(points, center) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            popup.style.left = `${(center.col + 0.5) * (500 / BOARD_SIZE)}px`;
            popup.style.top = `${(center.row + 0.5) * (500 / BOARD_SIZE) + 80}px`; // +80 for header offset
            boardElement.appendChild(popup);
            
            // Remove after animation completes
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 1000);
        }
        
        // Update UI elements
        function updateUI() {
            scoreElement.textContent = score;
            movesElement.textContent = moves;
        }
        
        // End the game
        function endGame() {
            gameActive = false;
            finalScoreElement.textContent = score;
            messageElement.style.display = 'block';
            isAnimating = false;
        }
        
        // Event listeners
        resetButton.addEventListener('click', initGame);
        
        // Start the game
        initGame();
    </script>
</body>
</html>

