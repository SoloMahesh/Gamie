<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Spin</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Segoe UI', sans-serif; touch-action: none; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { display: block; }
        #score { position: absolute; top: 10%; font-size: 4rem; color: rgba(255,255,255,0.2); font-weight: bold; pointer-events: none; }
        #instructions { position: absolute; bottom: 10%; color: white; opacity: 0.5; pointer-events: none; }
        #gameOver { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 10; }
        button { padding: 15px 30px; font-size: 1.5rem; background: #0984e3; border: none; color: white; cursor: pointer; border-radius: 50px; margin-top: 20px; }
    </style>
</head>
<body>
    <div id="score">0</div>
    <div id="instructions">Tap Left/Right to Rotate</div>
    <canvas id="gameCanvas"></canvas>

    <div id="gameOver">
        <h1>Game Over</h1>
        <p>Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">Try Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        const colors = ['#e74c3c', '#f1c40f', '#2ecc71', '#3498db']; // Red, Yellow, Green, Blue
        let rotatorAngle = 0;
        let targetAngle = 0;
        let balls = [];
        let score = 0;
        let gameActive = true;
        let spawnRate = 100;
        let spawnTimer = 0;
        let particles = [];

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        function resetGame() {
            score = 0;
            balls = [];
            particles = [];
            rotatorAngle = 0;
            targetAngle = 0;
            spawnRate = 100;
            spawnTimer = 0;
            gameActive = true;
            document.getElementById('score').innerText = score;
            document.getElementById('gameOver').style.display = 'none';
        }

        function spawnBall() {
            const colorIdx = Math.floor(Math.random() * 4);
            balls.push({
                y: -20,
                colorIdx: colorIdx,
                color: colors[colorIdx],
                speed: 3 + Math.min(5, score * 0.1)
            });
        }

        function createParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 30,
                    color: color
                });
            }
        }

        function update() {
            if (!gameActive) return;

            // Rotation smoothing
            rotatorAngle += (targetAngle - rotatorAngle) * 0.2;

            // Spawn
            spawnTimer++;
            if (spawnTimer > spawnRate) {
                spawnBall();
                spawnTimer = 0;
                if (spawnRate > 40) spawnRate--;
            }

            // Balls
            for (let i = balls.length - 1; i >= 0; i--) {
                const b = balls[i];
                b.y += b.speed;

                // Collision
                const rotatorY = height / 2 + 100; // Center of rotator
                const rotatorRadius = 60;

                if (b.y > rotatorY - rotatorRadius - 10) {
                    // Check match
                    // Rotator has 4 segments:
                    // 0: 315-45 (Top when 0 deg) - Red
                    // 1: 45-135 (Right) - Blue
                    // 2: 135-225 (Bottom) - Green
                    // 3: 225-315 (Left) - Yellow

                    // Wait, let's define segments properly
                    // Visual rendering:
                    // Arc 0: -PI/4 to -3PI/4 (Top-Left) ?
                    // Let's standard:
                    // 0: Top (Red)
                    // 1: Right (Yellow)
                    // 2: Bottom (Green)
                    // 3: Left (Blue)

                    // Angle 0 puts Red at Top.
                    // Rotation is added.
                    // If we rotate 90 deg (PI/2), Blue moves to Top.
                    // So Top Color Index depends on rotation.
                    // Angle 0 -> Idx 0 at top.
                    // Angle 90 -> Idx 3 at top.
                    // Angle 180 -> Idx 2 at top.
                    // Angle 270 -> Idx 1 at top.
                    // Basically: (0 - rotation / 90) % 4

                    // Normalized angle (0 to 360)
                    let deg = (rotatorAngle * 180 / Math.PI) % 360;
                    if (deg < 0) deg += 360;

                    // Which quadrant is facing UP (270 deg / -90 deg visual)? No, ball falls from TOP (270/-90 in standard math, but here Y is down so 270 is up).
                    // Actually let's just trace the angle.
                    // Segment 0 (Red) starts at -45 deg to 45 deg (centered at 0, facing Right)??
                    // Let's implement render first to match logic.

                    // Re-Logic:
                    // Render:
                    // 0 (Red): -PI/4 to -3PI/4 (Top)
                    // Wait, circle arcs.
                    // Let's say Red is normally Top (-PI/2).
                    // Width PI/2. So -3PI/4 to -PI/4.

                    // Check:
                    // Effective rotation of the wheel relative to the ball (which is at -PI/2 angle relative to center)
                    // Ball hits top.
                    // We need the color of the sector at -PI/2.
                    // Wheel is rotated by `rotatorAngle`.
                    // So we look up color at angle (-PI/2 - rotatorAngle).

                    // Map angle to index 0-3.
                    // 0: Red, 1: Yellow, 2: Green, 3: Blue

                    // hitAngle = -PI/2 - rotatorAngle
                    // Normalize to 0-2PI
                    let hitA = (-Math.PI/2 - rotatorAngle) % (Math.PI * 2);
                    if (hitA < 0) hitA += Math.PI * 2;

                    // Sectors: 0(Red), 1(Yellow), 2(Green), 3(Blue) distributed 0-2PI?
                    // Let's define:
                    // 0 (Red): 0 - PI/2
                    // 1 (Yellow): PI/2 - PI
                    // 2 (Green): PI - 3PI/2
                    // 3 (Blue): 3PI/2 - 2PI

                    // Wait, ball hits Top. That is angle 3PI/2 (270 deg) in standard circle, or -PI/2.
                    // So we check which sector contains `hitA`.

                    let sector = Math.floor(hitA / (Math.PI/2));

                    // Map sector to color index
                    // If my render draws Red at 0-90, Yellow 90-180...
                    // Then logic holds.

                    if (sector === b.colorIdx) {
                        // Match
                        score++;
                        document.getElementById('score').innerText = score;
                        createParticles(width/2, b.y, b.color);
                        balls.splice(i, 1);
                    } else {
                        // Fail
                        gameOver();
                    }
                }
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('finalScore').innerText = score;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            const cx = width / 2;
            const cy = height / 2 + 100;
            const r = 80;
            const thickness = 20;

            // Draw Rotator
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(rotatorAngle);

            for(let i=0; i<4; i++) {
                ctx.beginPath();
                ctx.arc(0, 0, r, i * Math.PI/2, (i+1) * Math.PI/2);
                ctx.strokeStyle = colors[i];
                ctx.lineWidth = thickness;
                ctx.stroke();
            }

            // Inner circle
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.arc(0, 0, r - thickness/2, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();

            // Draw Balls
            balls.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(cx, b.y, 15, 0, Math.PI * 2);
                ctx.fill();
            });

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x, p.y, 5, 5);
                ctx.globalAlpha = 1;
            });
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Input
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') targetAngle -= Math.PI / 2;
            if (e.key === 'ArrowRight') targetAngle += Math.PI / 2;
        });

        document.addEventListener('touchstart', e => {
            e.preventDefault();
            if (!gameActive) return;
            if (e.touches[0].clientX < width / 2) {
                targetAngle -= Math.PI / 2;
            } else {
                targetAngle += Math.PI / 2;
            }
        }, {passive: false});

        document.addEventListener('mousedown', e => {
            if (!gameActive) return;
            if (e.clientX < width / 2) {
                targetAngle -= Math.PI / 2;
            } else {
                targetAngle += Math.PI / 2;
            }
        });

        resetGame();
        loop();

    </script>
</body>
</html>
